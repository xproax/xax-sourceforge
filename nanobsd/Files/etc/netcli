#!/usr/bin/env python
#+
# Copyright 2010 iXsystems, Inc.
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# $FreeBSD$
#####################################################################

import os
import re
import signal
import sys
import subprocess

import ipaddr

WWW_PATH = "/usr/local/www"
FREENAS_PATH = os.path.join(WWW_PATH, "freenasUI")
NETWORK_PATH = os.path.join(FREENAS_PATH, "network")
NOTIFIER_PATH = os.path.join(FREENAS_PATH, "middleware/notifier.py")

FREENAS_DATA_PATH = "/data"
FREENAS_DB = os.path.join(FREENAS_DATA_PATH, "freenas-v1.db")

sys.path.append(WWW_PATH)
sys.path.append(FREENAS_PATH)
sys.path.append(NETWORK_PATH)

os.environ["DJANGO_SETTINGS_MODULE"] = "freenasUI.settings"

from django.contrib.auth.models import User

from freenasUI.choices import NICChoices, LAGGType
from freenasUI.network.models import GlobalConfiguration, Interfaces, \
	LAGGInterface, LAGGInterfaceMembers, StaticRoute, VLAN
from freenasUI.system.models import Settings
from freenasUI.middleware.notifier import notifier


def quad_to_cidr(quad):
    vals = { 0:True, 128:True, 192:True,
             224:True, 240:True, 248:True,
             252:True, 254:True, 255:True }
	
    count = 0
    octets = quad.split('.')
    for octet in octets:
        i = 7
        o = int(octet)
        if vals.get(o):
            while i >= 0:
                if o & (1 << i):
                    count += 1
                else:
                    return count
                i -= 1

        else:
            return False

    return count


def hex_to_cidr(_hex):
    h = _hex.replace("0x", "")
    h = h.replace("0X", "")
    h = int(h, 16)

    i = 31
    count = 0
    while h & (1 << i):
        count += 1
        i -= 1

    return count


def prompt(prompt_str, default_value=None):
    """Returns a string that forms a prompt, based on values passed in"""
    if default_value:
        default_str = ' [%s]' % (str(default_value), )
    else:
        default_str = ''
    return (prompt_str + default_str + ':')


def get_nic(choices=None):
    nic = False

    if choices is None:
        choices = NICChoices()

    while True:
        nics = []
        for i, c in enumerate(choices):
            nics.append(c[0])
            print "%d) %s" % (i + 1, nics[i])

        _input = raw_input("Select an interface (q to quit): ")
        if _input.isdigit() and _input in range(1, len(nics)+1):
            nic = nics[int(_input) - 1]
            break
        elif _input.lower().startswith("q"):
            return False

    return nic


def get_lagg_proto():
    proto = False

    while True:
        protos = { }
        types = LAGGType
        for i, t in enumerate(types):
            protos[i] = t[0]
            print "%d) %s" % (i + 1, protos[i])

        _input = raw_input("Select a lagg protocol (q to quit): ")
        if _input.isdigit() and int(_input) in xrange(1, len(protos)+1):
            proto = protos[int(_input) - 1]
            break
        elif _input.lower().startswith("q"):
            return False

    return proto


def get_lagg_nics(nics=None):

    group = [ ]

    if nics is None:
        nics = NICChoices(nolagg=True)

    while True:
        nic = get_nic(nics)
        if not nic:
            break

        nics.remove(nic)
        group.append(nic)

    return group


def configure_interface():
    while True:
        nics = []
        choices = NICChoices(include_vlan_parent=True, exclude_configured=False)
        for i, c in enumerate(choices):
            nics.append(c[0])
            print "%d) %s" % (i + 1, nics[i])

        _input = raw_input("Select an interface (q to quit): ")
        if _input.isdigit() and int(_input) in xrange(1, len(nics)+1):
            nic = nics[int(_input) - 1]
            break
        elif _input.lower().startswith("q"):
            return True

    iface = Interfaces.objects.filter(int_interface = nic)
    if iface:
        iface = iface[0]
    else:
        iface = Interfaces()

    while True:
        _input = raw_input("Reset network configuration? (y/n) ").lower()
        if _input.startswith("y"):
            print "Resetting interface configuration:",
            try:
                if iface.id != None:
                    iface.int_ipv4address = ''
                    iface.int_v4netmaskbit = ''
                    iface.int_dhcp = False
                    iface.save()
            except Exception, err:
                print "Failed %s" % str(err)
                return False
            print "Ok"
            print "Restarting network:",
            try:
                notifier().start("network")
            except:
                print "Failed"
            print "ok"
            print "Restarting routing:",
            try:
                notifier().restart("routing")
            except:
                print "Failed"
            print "ok"
            return True
        elif _input.startswith('n'):
            break
        else:
            continue

    need_restart = False
    while True:
        _input = raw_input("Configure interface for DHCP? (y/n) ")
        if _input.lower().startswith("y"):
            int_name_prompt = prompt("Interface name", iface.int_name)
            int_name = raw_input(int_name_prompt)
            if not int_name and iface.int_name:
                int_name = iface.int_name
            iface.int_interface = nic
            iface.int_dhcp = True
            iface.int_ipv4address = ""
            iface.int_v4netmaskbit = ""
            print "Saving interface configuration:",
            try:
                iface.save()
            except Exception, err:
                print "Failed %s" % str(err)
                return False
            print "Ok"
            need_restart = "DHCP"
            gc = GlobalConfiguration.objects.all()
            gc = gc[0]
            gc.gc_ipv4gateway = ''

            print "Removing IPv4 default gateway:",
            try:
                gc.save()
            except:
                print "Failed"
                return False
            print "Ok"
            break
        elif _input.lower().startswith('n'):
            break
        else:
            continue

    while True and need_restart != "DHCP":
        yes = raw_input("Configure IPv4? (y/n) ")
        if yes.lower().startswith("y"):
            int_name_prompt = prompt("Interface name", iface.int_name)
            int_name = raw_input(int_name_prompt)
            if not int_name and iface.int_name:
                int_name = iface.int_name
            ip_prompt = prompt("IPv4 Address", iface.int_ipv4address)
            mask_prompt = prompt("IPv4 Netmask", iface.int_v4netmaskbit)
            print "Several input formats are supported"
            print "Example 1 CIDR Notation:"
            print "    192.168.1.1/24"
            print "Example 2 IP and Netmask seperate:"
            print "    IP: 192.168.1.1"
            print "    Netmask: 255.255.255.0, /24 or 24"

            ip = mask = None
            while True:
                ip = raw_input(ip_prompt)

                if not ip and iface.int_ipv4address:
                    ip = iface.int_ipv4address

                try:
                    try:
                        ipaddr.IPNetwork(ip, version=4)
                    except ValueError:
                        print "Invalid value entered"
                        continue
                    ip, mask = ip.split('/')
                    break
                except:
                    mask = raw_input(mask_prompt)
                    if mask.startswith("/"):
                        mask = mask.lstrip("/")
                    if not mask and iface.int_v4netmaskbit:
                        mask = iface.int_v4netmaskbit
                        break
                    elif re.match(r"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]"
                                   "[0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|"
                                   "[01]?[0-9][0-9]?)$", mask):
                        try:
                            ipaddr.IPAddress(mask, version=4)
                        except ValueError:
                            print "Invalid Netmask"
                            continue
                        mask = quad_to_cidr(mask)
                        break
                    elif re.match("^(0[xX])?([0-9a-fA-F]){8}$", mask):
                        mask = hex_to_cidr(mask)
                        break
                    elif int(mask) > 0 and int(mask) < 33:
                        mask = int(mask, 10)
                        break
                    else:
                        print "Enter netmask as a dotted quad, a hex number,",
                        print "or CIDR prefix"
                        print "Acceptable formats are 255.255.255.0,",
                        print "0xffffff00,",
                        print "/24, or 24"
                        continue

            iface.int_interface = nic
            iface.int_name = int_name
            iface.int_ipv4address = ip
            iface.int_v4netmaskbit = mask
            iface.int_dhcp = False
            print "Saving interface configuration:",
            try:
                iface.save()
            except:
                print "Failed"
                return False
            print "Ok"
            need_restart = True
            break
        elif yes.lower().startswith("n"):
            break

    while True:
        yes = raw_input("Configure IPv6? (y/n) ")
        if yes.lower().startswith("y"):
            ip_prompt = prompt("IPv6 Address", iface.int_ipv6address)
            mask_prompt = prompt("IPv6 Netmask", iface.int_v6netmaskbit)

            ip = mask = None
            ip = raw_input(ip_prompt)
            if not ip and iface.int_ipv6address:
                ip = iface.int_ipv6address

            try:
                try:
                    ipaddr.IPNetwork(ip, version=6)
                except ValueError:
                    print "Invalid value entered"
                    continue
                ip, mask = ip.split('/')
            except:
                while True:
                    mask = raw_input(mask_prompt)
                    if not mask and iface.int_v6netmask:
                        if int(mask) > 0 and int(mask) < 128:
                            mask = iface.int_v6netmaskbit
                            break
                        else:
                            print "Enter ipv6 netmask as number of bits eg: 64"
                            continue

            iface.int_interface = nic
            iface.int_ipv6address = ip
            iface.int_v6netmaskbit = mask

            print "Saving interface configuration:",
            try:
                iface.save()
            except:
                print "Failed"
                return False
            print "Ok"
            if not need_restart:
                need_restart = True
            break

        elif yes.lower().startswith("n"):
            break

    if need_restart:
        print "Restarting network:",
        try:
            notifier().start("network")
        except:
            print "Failed"
        print "ok"
    if need_restart == "DHCP":
        print "Restarting routing:",
        try:
            notifier().restart("routing")
        except:
            print "Failed"
        print "ok"
        return True

def reset_gui_login():
    User.objects.all().delete()
    admin = User.objects.create(username="admin", email="freenas@local.domain",
                                is_superuser=True, is_staff=True)
    admin.set_unusable_password()
    admin.save()
    print """
    The login information for the WebGUI has been reseted.

    Press Enter to continue
    """
    raw_input("")

def reset_factory_defaults():
    a = raw_input('Are you sure you want to reset to factory defaults? '
                  '(yes/no): ')
    if a.lower().startswith('y'):
        notifier().config_restore()
        os.system("/sbin/reboot")

def configure_lagg_interface():
    lagg_index = 0
    lagg_interfaces = LAGGInterface.objects.all()
    for li in lagg_interfaces:
        lagg_index = int(re.split('([0-9]+)$', str(li.lagg_interface))[1]) + 1

    lagg_proto = get_lagg_proto()
    if not lagg_proto:
        return True

    lagg_nics = get_lagg_nics()
    if not lagg_nics:
        return True

    lagg_name = 'lagg%d' % lagg_index
    iface = Interfaces(int_interface = lagg_name, int_name = lagg_name,
        int_dhcp = True, int_ipv6auto = False)

    print "Saving interface configuration:",
    try:
        iface.save()
    except:
        print "Failed"
        return False
    print "Ok"  

    lagg_iface = LAGGInterface(lagg_interface = iface,
                               lagg_protocol = lagg_proto)

    print "Saving Link Aggregation configuration:",
    try:
        lagg_iface.save()
    except:
        print "Failed"
        return False
    print "Ok"

    order = 0
    for nic in lagg_nics: 
        lagg_iface_member = LAGGInterfaceMembers(lagg_interfacegroup =
                                                 lagg_iface,
                                                 lagg_ordernum = order,
                                                 lagg_physnic = nic,
                                                 lagg_deviceoptions = 'up')

        print "Saving Link Aggregation member configuration:",
        try:
            lagg_iface_member.save()
        except:
            print "Failed"
            return False
        print "Ok"

        order += 1

    print "The system must be rebooted for these changes to take effect."
    return True

def create_vlan():

    vlan = VLAN()

    # Select parent interface
    while True:
        nics = []
        choices = NICChoices(novlan=True)
        for i, c in enumerate(choices):
            nics.append(c[0])
            print "%2d) %s" % (i + 1, nics[i])

        _input = raw_input("Select a parent interface (q to quit): ")
        if _input.isdigit() and _input in xrange(1, len(nics)+1):
            vlan_pint = nics[int(_input) - 1]
            break
        elif _input.lower().startswith("q"):
            return True
    # Get interface name
    while True:
        vlan_vint = raw_input("Enter an interface name "
                              "(vlanXX) or a to abort: ")
        if vlan_vint == "a":
            return
        if not re.match(r'vlan\d+', vlan_vint):
            print "Interface name must be vlanXX where XX is a number"
            continue
        break
    # Get vlan tag
    while True:
        vlan_tag = raw_input("Enter a VLAN Tag or a to abort: ")
        if vlan_tag == "a":
            return
        if not re.match(r'\d+', vlan_tag):
            print "VLAN Tag must be an integer"
            continue
        break
    # Get VLAN description
    vlan_description = raw_input("Enter VLAN description: ")

    vlan.vlan_pint = vlan_pint
    vlan.vlan_vint = vlan_vint
    vlan.vlan_tag = vlan_tag
    vlan.vlan_description = vlan_description
    print "Saving VLAN interface:",
    try:
        vlan.save()
    except:
        print "Failed"
        return False
    print "Ok"
    print "Restarting network:",
    try:
        notifier().start("network")
    except:
        print "Failed"
        return False
    print "ok"
    return True

def configure_ipv4_default_route(gc):
    gwprompt = prompt("IPv4 Default Route", gc.gc_ipv4gateway)

    gateway = raw_input(gwprompt)
    if gateway:
        try:
            ipaddr.IPAddress(gateway, version=4)
        except ValueError:
            print "Invalid value entered"
            return False
        gc.gc_ipv4gateway = gateway 

        print "Saving IPv4 gateway:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "Ok"
        return True
    else:
        print "No default route entered."
        return False

def configure_ipv6_default_route(gc):
    gwprompt = prompt("IPv6 Default Route", gc.gc_ipv6gateway)

    gateway = raw_input(gwprompt)
    if gateway:
        try:
            ipaddr.IPAddress(gateway, version=6)
        except ValueError:
            print "Invalid value entered"
            return False
        gc.gc_ipv6gateway = gateway 
        print "Saving IPv6 gateway:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "Ok"
        return True
    else:
        print "No default route entered."
        return False

def configure_default_route():
    gc = GlobalConfiguration.objects.all()
    gc = gc[0]
    need_save = False

    while True:
        yes = raw_input("Configure IPv4 Default Route? (y/n)")
        if yes.lower().startswith("y"):
            configure_ipv4_default_route(gc)
            need_save = True
            break
        elif yes.lower().startswith("n"):
            break

    while True:
        yes = raw_input("Configure IPv6 Default Route? (y/n)")
        if yes.lower().startswith("y"):
            configure_ipv6_default_route(gc)
            need_save = True
            break
        elif yes.lower().startswith("n"):
            break

    if need_save:
        print "Restarting routing:",
        try:
            notifier().restart("routing")
        except:
            print "Failed"
            return False
        print "ok"
        return True
    else:
        print "Routing configuration unchanged."
        return True

def configure_static_routes():
    dest = raw_input("Destination network: ")
    gateway = raw_input("Gateway: ")
    desc = raw_input("Description: ")

    try:
        ipaddr.IPNetwork(dest)
    except ValueError:
        print "Invalid destination network"
        return False
    try:
        ipaddr.IPAddress(gateway)
    except ValueError:
        print "Invalid gateway"
        return False

    sr = StaticRoute()
    sr.sr_destination = dest
    sr.sr_gateway = gateway
    if desc:
        sr.sr_description = desc
    print "Saving static route:",
    try:
        sr.save()
    except:
        print "Failed"
        return False
    print "ok"
    try:
        print "Restarting routing:",
        notifier().restart("routing")
    except:
        print "Failed"
        return False
    print "ok"
    return True

def configure_dns():
    ns1 = ns2 = ns3 = domain = None
    gc = GlobalConfiguration.objects.all()
    gc = gc[0]

    domain_prompt = prompt("DNS Domain", gc.gc_domain)
    ns1_prompt = prompt("DNS Nameserver 1", gc.gc_nameserver1)
    ns2_prompt = prompt("DNS Nameserver 2", gc.gc_nameserver2)
    ns3_prompt = prompt("DNS Nameserver 3", gc.gc_nameserver3)

    domain = raw_input(domain_prompt)
    if domain:
        gc.gc_domain = domain

    need_save = False
    print "Enter nameserver IPs, an empty value ends input"
    while True:
        ns1 = raw_input(ns1_prompt)
        if ns1:
            try:
                ipaddr.IPAddress(ns1, version=4)
            except ValueError:
                print "Invalid nameserver"
                return False
            gc.gc_nameserver1 = ns1
            need_save = True
            gc.gc_nameserver2 = ''
            gc.gc_nameserver3 = ''
        else:
            return False

        ns2 = raw_input(ns2_prompt)
        if ns2:
            try:
                ipaddr.IPAddress(ns2, version=4)
            except ValueError:
                print "Invalid nameserver"
                break
            gc.gc_nameserver2 = ns2
        else:
            break

        ns3 = raw_input(ns3_prompt)
        if ns3:
            try:
                ipaddr.IPAddress(ns3, version=4)
            except ValueError:
                print "Invalid nameserver"
                break
            gc.gc_nameserver3 = ns3
        break

    if need_save:
        print "Saving DNS configuration:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "ok"

        print "Reloading network config:",
        try:
            notifier().reload("networkgeneral")
        except:
            print "Failed"
            return False
        print "ok"
        return True

def shell():
    return os.system("/usr/bin/su -l root")


def reboot():
    while True:
        ret = raw_input("Confirm reboot (y/n): ")
        if ret.lower().startswith("y"):
            os.system("/sbin/reboot")
        if ret.lower().startswith("n"):
            return False

def shutdown():
    while True:
        ret = raw_input("Confirm Shutdown (y/n): ")
        if ret.lower().startswith("y"):
            os.system("/sbin/shutdown -p now")
        if ret.lower().startswith("n"):
            return False

def show_ip():
    proto = Settings.objects.all().order_by('-id')[0].stg_guiprotocol
    p1 = subprocess.Popen("sockstat |awk '{ if ($2 == \"lighttpd\" && $7 == \"*:*\") print $6 }'", shell=True, stdout=subprocess.PIPE)
    addrs = p1.communicate()[0].split('\n')[:-1]

    if addrs:
        print """
You may try the following URLs to access the web user interface:
"""

        for addr in addrs:
            ip, port = addr.split(':')
            hide_port = True if (proto == 'http' and port == '80') or \
                             (proto == 'https' and port == '443') else False
            if ip == '*':
                if hide_port:
                    os.system('ifconfig -a inet | grep broadcast | cut -f2 -d\  |'
                      'sed -e s,^,%s://,g -e s,$,/,g' % proto)
                else:
                    os.system('ifconfig -a inet | grep broadcast | cut -f2 -d\  |'
                      'sed -e s,^,%s://,g -e s,$,:%s/,g' % (proto, port))
            else:
                if hide_port:
                    print "%s://%s/" % (proto, ip)
                else:
                    print "%s://%s/" % (proto, addr)

        print

def main_menu():
    menu = [
        [ "Configure Network Interfaces", configure_interface ],
        [ "Configure Link Aggregation", configure_lagg_interface ],
        [ "Create VLAN Interface", create_vlan ],
        [ "Configure Default Route", configure_default_route ],
        [ "Configure Static Routes", configure_static_routes ],
        [ "Configure DNS", configure_dns ],
        [ "Reset WebGUI login credentials", reset_gui_login ],
        [ "Reset to factory defaults", reset_factory_defaults ],
        [ "Shell", shell ],
        [ "Reboot", reboot ],
        [ "Shutdown", shutdown],
              ]
    menu_map = {}
    menu_max = 0
    for item in menu:
        menu_max = menu_max + 1
        menu_map[menu_max] = item

    while True:
        print """
Console setup
-------------
        """
        for index in menu_map:
            print "%d) %s" % (index, menu_map[index][0])

        show_ip()

        try:
            ch = int(raw_input("Enter an option from 1-%d: " % (menu_max)))
        except ValueError:
            ch = None
        if ch in menu_map:
            menu_map[ch][1]()
        continue


#
#	No signal handling here, it is assumed that this script
#	will be setup in /etc/ttys, so we just exit ;-). 
#
if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_IGN)

    while True:
        try:
            main_menu()
        except:
            exit(1)
