#!/usr/bin/env python
#+
# Copyright 2010 iXsystems
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted providing that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# $FreeBSD$
#####################################################################

import os
import sys
from signal import signal, SIGINT, SIG_IGN
import re
import ipaddr

WWW_PATH = "/usr/local/www"
FREENAS_PATH = os.path.join(WWW_PATH, "freenasUI")
NETWORK_PATH = os.path.join(FREENAS_PATH, "network")
NOTIFIER_PATH = os.path.join(FREENAS_PATH, "middleware/notifier.py")

sys.path.append(WWW_PATH)
sys.path.append(FREENAS_PATH)
sys.path.append(NETWORK_PATH)

os.environ["DJANGO_SETTINGS_MODULE"] = "freenasUI.settings"

from django.db import models

from freenasUI.choices import NICChoices, LAGGType
from freenasUI.network import models
from freenasUI.network.models import GlobalConfiguration, Interfaces, \
	LAGGInterface, LAGGInterfaceMembers, StaticRoute, VLAN
from freenasUI.middleware.notifier import notifier


def quad_to_cidr(quad):
    vals = { 0:True, 128:True, 192:True,
             224:True, 240:True, 248:True,
             252:True, 254:True, 255:True }
	
    count = 0
    octets = quad.split('.')
    for oct in octets:
        i = 7
        o = int(oct)
        if vals.get(o):
            while i >= 0:
                if o & (1 << i):
                    count += 1
                else:
                    return count
                i -= 1

        else:
            return False

    return count


def hex_to_cidr(hex):
    h = hex.replace("0x", "")
    h = h.replace("0X", "")
    h = int(h, 16)

    i = 31
    count = 0
    while h & (1 << i):
        count += 1
        i -= 1

    return count


def prompt(s, val):
    """Returns a string that forms a prompt, based on values passed in"""
    prompt = []
    prompt.append(s) 
    if val:
        prompt.append(" ")
        prompt.append("[")
        prompt.append(str(val))
        prompt.append("]")
    prompt.append(": ")
    return "".join(prompt)


def get_nic(choices = NICChoices()):
    nic = False

    while True:
        i = 0
        nics = { }
        for c in choices:
            nics[i] = c[0]
            print "%d) %s" % (i + 1, nics[i])
            i += 1

        i = raw_input("Select an interface (q to quit): ")
        if i.isdigit() and nics.has_key(int(i) - 1):
            nic = nics[int(i) - 1]
            break
        elif i.lower().startswith("q"):
            return False
        else:
            continue

    return nic


def get_lagg_proto():
    proto = False

    while True:
        i = 0
        protos = { }
        types = LAGGType
        for t in types:
            protos[i] = t[0]
            print "%d) %s" % (i + 1, protos[i])
            i += 1

        i = raw_input("Select a lagg protocol (q to quit): ")
        if i.isdigit() and protos.has_key(int(i) - 1):
            proto = protos[int(i) - 1]
            break
        elif i.lower().startswith("q"):
            return False
        else:
            continue

    return proto


def get_lagg_nics(nics = NICChoices()):
    group = [ ]

    while True:
        nic = get_nic(nics)
        if not nic:
            break

        nics.remove(nic)
        group.append(nic)

    return group


def configure_interface():
    while True:
        i = 0
        nics = {}
        choices = NICChoices()
        for c in choices:
            nics[i] = c[0]
            print "%d) %s" % (i + 1, nics[i])
            i += 1
	
        regex = "^[1-%d]$" % i

        i = raw_input("Select an interface (q to quit): ")
        if re.match(regex, i):
            nic = nics[int(i) - 1]
            break
        elif i.lower().startswith("q"):
            return True
        else:
            continue

    iface = Interfaces.objects.filter(int_interface = nic)
    if iface:
        iface = iface[0]
    else:
        iface = Interfaces()

    need_restart = False
    while True:
        input = raw_input("Configure interface for DHCP? (y/n) ")
        if input.lower().startswith("y"):
            int_name_prompt = prompt("Interface name", iface.int_name)
            int_name = raw_input(int_name_prompt)
            if not int_name and iface.int_name:
                int_name = iface.int_name
            iface.int_interface = nic
            iface.int_dhcp = True
            iface.int_ipv4address = ""
            iface.int_v4netmaskbit = ""
            print "Saving interface configuration:",
            try:
                iface.save()
            except Exception, err:
                print "Failed %s" % str(err)
                return False
            print "Ok"
            need_restart = "DHCP"
            gc = GlobalConfiguration.objects.all()
            gc = gc[0]
            gc.gc_ipv4gateway = ''

            print "Removing IPv4 default gateway:",
            try:
                gc.save()
            except:
                print "Failed"
                return False
            print "Ok"
            break
        elif input.lower().startswith("n"):
            break
        else:
            continue

    while True and need_restart != "DHCP":
        yes = raw_input("Configure IPv4? (y/n) ")
        if yes.lower().startswith("y"):
            int_name_prompt = prompt("Interface name", iface.int_name)
            int_name = raw_input(int_name_prompt)
            if not int_name and iface.int_name:
                int_name = iface.int_name
            ip_prompt = prompt("IPv4 Address", iface.int_ipv4address)
            mask_prompt = prompt("IPv4 Netmask", iface.int_v4netmaskbit)
            print "Several input formats are supported"
            print "Example 1 CIDR Notation:"
            print "    192.168.1.1/24"
            print "Example 2 IP and Netmask seperate:"
            print "    IP: 192.168.1.1"
            print "    Netmask: 255.255.255.0, /24 or 24"

            ip = mask = None
            while True:
                ip = raw_input(ip_prompt)

                if not ip and iface.int_ipv4address:
                    ip = iface.int_ipv4address

                try:
                    try:
                        ipaddr.IPNetwork(ip, version=4)
                    except ValueError:
                        print "Invalid value entered"
                        continue
                    ip, mask = ip.split('/')
                    break
                except:
                    mask = raw_input(mask_prompt)
                    if mask.startswith("/"):
                        mask = mask.lstrip("/")
                    if not mask and iface.int_v4netmaskbit:
                        mask = iface.int_v4netmaskbit
                        break
                    elif re.match(r"^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9]"
                                   "[0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|"
                                   "[01]?[0-9][0-9]?)$", mask):
                        try:
                            ipaddr.IPAddress(mask, version=4)
                        except ValueError:
                            print "Invalid Netmask"
                            continue
                        mask = quad_to_cidr(mask)
                        break
                    elif re.match("^(0[xX])?([0-9a-fA-F]){8}$", mask):
                        mask = hex_to_cidr(mask)
                        break
                    elif int(mask) > 0 and int(mask) < 33:
                        mask = int(mask, 10)
                        break
                    else:
                        print "Enter netmask as a dotted quad, a hex number,",
                        print "or CIDR prefix"
                        print "Acceptable formats are 255.255.255.0,",
                        print "0xffffff00,",
                        print "/24, or 24"
                        continue

            iface.int_interface = nic
            iface.int_name = int_name
            iface.int_ipv4address = ip
            iface.int_v4netmaskbit = mask
            iface.int_dhcp = False
            print "Saving interface configuration:",
            try:
                iface.save()
            except:
                print "Failed"
                return False
            print "Ok"
            need_restart = True
            break
        elif yes.lower().startswith("n"):
            break

    while True:
        yes = raw_input("Configure IPv6? (y/n)")
        if yes.lower().startswith("y"):
            ip_prompt = prompt("IPv6 Address", iface.int_ipv6address)
            mask_prompt = prompt("IPv6 Netmask", iface.int_v6netmaskbit)

            ip = mask = None
            ip = raw_input(ip_prompt)
            if not ip and iface.int_ipv6address:
                ip = iface.int_ipv6address

            try:
                try:
                    ipaddr.IPNetwork(ip, version=6)
                except ValueError:
                    print "Invalid value entered"
                    continue
                ip, mask = ip.split('/')
            except:
                while True:
                    mask = raw_input(mask_prompt)
                    if not mask and iface.int_v6netmask:
                        if int(mask) > 0 and int(mask) < 128:
                            mask = iface.int_v6netmaskbit
                            break
                        else:
                            print "Enter ipv6 netmask as number of bits eg: 64"
                            continue

            iface.int_interface = nic
            iface.int_ipv6address = ip
            iface.int_v6netmaskbit = mask

            print "Saving interface configuration:",
            try:
                iface.save()
            except:
                print "Failed"
                return False
            print "Ok"
            if not need_restart:
                need_restart = True
            break

        elif yes.lower().startswith("n"):
            break

    if need_restart:
        print "Restarting network:",
        try:
            notifier().start("network")
        except:
            print "Failed"
        print "ok"
    if need_restart == "DHCP":
        print "Restarting routing:",
        try:
            notifier().restart("routing")
        except:
            print "Failed"
        print "ok"
        return True

def configure_lagg_interface():
    lagg_index = 0
    lagg_interfaces = LAGGInterface.objects.all()
    for li in lagg_interfaces:
        lagg_index = int(re.split('([0-9]+)$', str(li.lagg_interface))[1]) + 1

    lagg_proto = get_lagg_proto()
    if not lagg_proto:
        return True

    lagg_nics = get_lagg_nics()
    if not lagg_nics:
        return True

    lagg_name = 'lagg%d' % lagg_index
    iface = Interfaces(int_interface = lagg_name, int_name = lagg_name,
        int_dhcp = True, int_ipv6auto = False)

    print "Saving interface configuration:",
    try:
        iface.save()
    except:
        print "Failed"
        return False
    print "Ok"  

    lagg_iface = LAGGInterface(lagg_interface = iface,
                               lagg_protocol = lagg_proto)

    print "Saving Link Aggregation configuration:",
    try:
        lagg_iface.save()
    except:
        print "Failed"
        return False
    print "Ok"

    order = 0
    for nic in lagg_nics: 
        lagg_iface_member = LAGGInterfaceMembers(lagg_interfacegroup =
                                                 lagg_iface,
                                                 lagg_ordernum = order,
                                                 lagg_physnic = nic,
                                                 lagg_deviceoptions = 'up')

        print "Saving Link Aggregation member configuration:",
        try:
            lagg_iface_member.save()
        except:
            print "Failed"
            return False
        print "Ok"

        order += 1

    print "The system must be rebooted for these changes to take effect."
    return True

def create_vlan():

    vlan = VLAN()

    # Select parent interface
    while True:
        i = 0
        nics = {}
        choices = NICChoices(novlan=True)
        for c in choices:
            nics[i] = c[0]
            print "%d) %s" % (i + 1, nics[i])
            i += 1
	
        regex = "^[1-%d]$" % i

        i = raw_input("Select a parent interface (q to quit): ")
        if re.match(regex, i):
            vlan_pint = nics[int(i) - 1]
            break
        elif i.lower().startswith("q"):
            return True
        else:
            continue
    # Get interface name
    while True:
        vlan_vint = raw_input("Enter an interface name "
                              "(vlanXX) or a to abort: ")
        if vlan_vint == "a":
            return
        if not re.match(r'vlan\d+', vlan_vint):
            print "Interface name must be vlanXX where XX is a number"
            continue
        break
    # Get vlan tag
    while True:
        vlan_tag = raw_input("Enter a VLAN Tag or a to abort: ")
        if vlan_tag == "a":
            return
        if not re.match(r'\d+', vlan_tag):
            print "VLAN Tag must be an integer"
            continue
        break
    # Get VLAN description
    vlan_description = raw_input("Enter VLAN description: ")

    vlan.vlan_pint = vlan_pint
    vlan.vlan_vint = vlan_vint
    vlan.vlan_tag = vlan_tag
    vlan.vlan_description = vlan_description
    print "Saving VLAN interface:",
    try:
        vlan.save()
    except:
        print "Failed"
        return False
    print "Ok"
    print "Restarting network:",
    try:
        notifier().start("network")
    except:
        print "Failed"
        return False
    print "ok"
    return True

def configure_ipv4_default_route(gc):
    gwprompt = prompt("IPv4 Default Route", gc.gc_ipv4gateway)

    gateway = raw_input(gwprompt)
    if gateway:
        try:
            ipaddr.IPAddress(gateway, version=4)
        except ValueError:
            print "Invalid value entered"
            return False
        gc.gc_ipv4gateway = gateway 

        print "Saving IPv4 gateway:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "Ok"
        return True
    else:
        print "No default route entered."
        return False

def configure_ipv6_default_route(gc):
    gwprompt = prompt("IPv6 Default Route", gc.gc_ipv6gateway)

    gateway = raw_input(gwprompt)
    if gateway:
        try:
            ipaddr.IPAddress(gateway, version=6)
        except ValueError:
            print "Invalid value entered"
            return False
        gc.gc_ipv6gateway = gateway 
        print "Saving IPv6 gateway:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "Ok"
        return True
    else:
        print "No default route entered."
        return False

def configure_default_route():
    gc = GlobalConfiguration.objects.all()
    gc = gc[0]
    need_save = False

    while True:
        yes = raw_input("Configure IPv4 Default Route? (y/n)")
        if yes.lower().startswith("y"):
            configure_ipv4_default_route(gc)
            need_save = True
            break
        elif yes.lower().startswith("n"):
            break

    while True:
        yes = raw_input("Configure IPv6 Default Route? (y/n)")
        if yes.lower().startswith("y"):
            configure_ipv6_default_route(gc)
            need_save = True
            break
        elif yes.lower().startswith("n"):
            break

    if need_save:
        print "Restarting routing:",
        try:
            notifier().restart("routing")
        except:
            print "Failed"
            return False
        print "ok"
        return True
    else:
        print "Routing configuration unchanged."
        return True

def configure_static_routes():
    dest = raw_input("Destination network: ")
    gateway = raw_input("Gateway: ")
    desc = raw_input("Description: ")

    try:
        ipaddr.IPNetwork(dest)
    except ValueError:
        print "Invalid destination network"
        return False
    try:
        ipaddr.IPAddress(gateway)
    except ValueError:
        print "Invalid gateway"
        return False

    sr = StaticRoute()
    sr.sr_destination = dest
    sr.sr_gateway = gateway
    if desc:
        sr.sr_description = desc
    print "Saving static route:",
    try:
        sr.save()
    except:
        print "Failed"
        return false
    print "ok"
    try:
        print "Restarting routing:",
        notifier().restart("routing")
    except:
        print "Failed"
        return False
    print "ok"
    return True

def configure_dns():
    ns1 = ns2 = ns3 = domain = None
    gc = GlobalConfiguration.objects.all()
    gc = gc[0]

    domain_prompt = prompt("DNS Domain", gc.gc_domain)
    ns1_prompt = prompt("DNS Nameserver 1", gc.gc_nameserver1)
    ns2_prompt = prompt("DNS Nameserver 2", gc.gc_nameserver2)
    ns3_prompt = prompt("DNS Nameserver 3", gc.gc_nameserver3)

    domain = raw_input(domain_prompt)
    if domain:
        gc.gc_domain = domain

    need_save = False
    print "Enter nameserver IPs, an empty value ends input"
    while True:
        ns1 = raw_input(ns1_prompt)
        if ns1:
            try:
                ipaddr.IPAddress(ns1, version=4)
            except ValueError:
                print "Invalid nameserver"
                return False
            gc.gc_nameserver1 = ns1
            need_save = True
            gc.gc_nameserver2 = ''
            gc.gc_nameserver3 = ''
        else:
            return False

        ns2 = raw_input(ns2_prompt)
        if ns2:
            try:
                ipaddr.IPAddress(ns2, version=4)
            except ValueError:
                print "Invalid nameserver"
                break
            gc.gc_nameserver2 = ns2
        else:
            break

        ns3 = raw_input(ns3_prompt)
        if ns3:
            try:
                ipaddr.IPAddress(ns3, version=4)
            except ValueError:
                print "Invalid nameserver"
                break
            gc.gc_nameserver3 = ns3
        break

    if need_save:
        print "Saving DNS configuration:",
        try:
            gc.save()
        except:
            print "Failed"
            return False
        print "ok"

        print "Reloading network config:",
        try:
            notifier().reload("networkgeneral")
        except:
            print "Failed"
            return False
        print "ok"
        return True

def forkexec(path, *args):
    pid = os.fork()
    if pid < 0:
        sys.exit(1)
    elif pid == 0:
        os.execvp(path, (path,) + tuple(args))
        os._exit(1)
    else:
        (cpid, status) = os.waitpid(pid, 0)

    return status


def shell():
    return forkexec("/bin/csh")


def reboot():
    while True:
        ret = raw_input("Confirm reboot (y/n): ")
        if ret.lower().startswith("y"):
            os.system("/sbin/reboot")
        if ret.lower().startswith("n"):
            return False

def shutdown():
    while True:
        ret = raw_input("Confirm Shutdown (y/n): ")
        if ret.lower().startswith("y"):
            os.system("/sbin/shutdown -p now")
        if ret.lower().startswith("n"):
            return False

def show_ip():
    from os import system
    ret = system("sockstat -4p 443 | grep lighttpd")
    if not ret:
        proto = "https"
    else:
        proto = "http"
    print """
You may try the following URLs to access the web user interface:
"""
    system('ifconfig -a inet | grep broadcast | cut -f2 -d\  |'
           'sed -e s,^,%s://,g -e s,$,/,g' % proto)

def main_menu():
    handler = { 1: configure_interface,
                2: configure_lagg_interface,
                3: create_vlan,
                4: configure_default_route,
                5: configure_static_routes,
                6: configure_dns,
                7: shell,
                8: reboot,
                9: shutdown
              }

    while True:
        print """
Console setup
-------------
1) Configure Network Interfaces
2) Configure Link Aggregation
3) Create VLAN Interface
4) Configure Default Route
5) Configure Static Routes
6) Configure DNS
7) Shell
8) Reboot
9) Shutdown
        """
        show_ip()

        ch = raw_input("Enter an option from 1-9: ")
        if re.match("^[1-9]$", ch):
            handler[int(ch)]()
            continue
        else:
            continue


#
#	No signal handling here, it is assumed that this script
#	will be setup in /etc/ttys, so we just exit ;-). 
#
if __name__ == '__main__':
    signal(SIGINT, SIG_IGN)

    while True:
        try:
            main_menu()
        except:
            exit(1)
