Index: sbin/geom
===================================================================
--- sbin/geom	(revision 236623)
+++ sbin/geom	(working copy)

Property changes on: sbin/geom
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /head/sbin/geom:r227464,227471,234415
   Merged /stable/8/sbin/geom:r221756,229308-229309,234917,235387
Index: sbin/geom/class/sched/gsched.8
===================================================================
--- sbin/geom/class/sched/gsched.8	(revision 236623)
+++ sbin/geom/class/sched/gsched.8	(working copy)

Property changes on: sbin/geom/class/sched/gsched.8
___________________________________________________________________
Modified: svn:mergeinfo
   Reverse-merged /head/sbin/geom/class/sched/gsched.8:r206497
   Merged /head/sbin/geom/class/sched/gsched.8:r227464,227471
   Merged /stable/8/sbin/geom/class/sched/gsched.8:r229309,234917,235387
Index: sbin/geom/class/part
===================================================================
--- sbin/geom/class/part	(revision 236623)
+++ sbin/geom/class/part	(working copy)

Property changes on: sbin/geom/class/part
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /head/sbin/geom/class/part:r227464,227471
   Merged /stable/8/sbin/geom/class/part:r229309,234917,235387
Index: sbin/geom/class/stripe
===================================================================
--- sbin/geom/class/stripe	(revision 236623)
+++ sbin/geom/class/stripe	(working copy)

Property changes on: sbin/geom/class/stripe
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /head/sbin/geom/class/stripe:r227464,227471
   Merged /stable/8/sbin/geom/class/stripe:r229309,234917,235387
Index: sbin/geom/class/multipath
===================================================================
--- sbin/geom/class/multipath	(revision 236623)
+++ sbin/geom/class/multipath	(working copy)

Property changes on: sbin/geom/class/multipath
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /head/sbin/geom/class/multipath:r227464,227471,234415
   Merged /stable/8/sbin/geom/class/multipath:r229309,234917,235387
Index: sbin/geom/class/multipath/geom_multipath.c
===================================================================
--- sbin/geom/class/multipath/geom_multipath.c	(revision 236623)
+++ sbin/geom/class/multipath/geom_multipath.c	(working copy)
@@ -36,6 +36,7 @@ __FBSDID("$FreeBSD$");
 #include <strings.h>
 #include <assert.h>
 #include <libgeom.h>
+#include <unistd.h>
 #include <uuid.h>
 #include <geom/multipath/g_multipath.h>
 
@@ -48,31 +49,69 @@ uint32_t version = G_MULTIPATH_VERSION;
 static void mp_main(struct gctl_req *, unsigned int);
 static void mp_label(struct gctl_req *);
 static void mp_clear(struct gctl_req *);
-static void mp_add(struct gctl_req *);
 
 struct g_command class_commands[] = {
 	{
-		"label", G_FLAG_VERBOSE | G_FLAG_LOADKLD, mp_main, G_NULL_OPTS,
-		NULL, "[-v] name prov ..."
+		"create", G_FLAG_VERBOSE | G_FLAG_LOADKLD, NULL,
+		{
+			{ 'A', "active_active", NULL, G_TYPE_BOOL },
+			{ 'R', "active_read", NULL, G_TYPE_BOOL },
+			G_OPT_SENTINEL
+		},
+		NULL, "[-vAR] name prov ..."
 	},
 	{
-		"add", G_FLAG_VERBOSE | G_FLAG_LOADKLD, mp_main, G_NULL_OPTS,
-		NULL, "[-v] name prov ..."
+		"label", G_FLAG_VERBOSE | G_FLAG_LOADKLD, mp_main,
+		{
+			{ 'A', "active_active", NULL, G_TYPE_BOOL },
+			{ 'R', "active_read", NULL, G_TYPE_BOOL },
+			G_OPT_SENTINEL
+		},
+		NULL, "[-vAR] name prov ..."
 	},
+	{ "configure", G_FLAG_VERBOSE, NULL,
+		{
+			{ 'A', "active_active", NULL, G_TYPE_BOOL },
+			{ 'P', "active_passive", NULL, G_TYPE_BOOL },
+			{ 'R', "active_read", NULL, G_TYPE_BOOL },
+			G_OPT_SENTINEL
+		},
+		NULL, "[-vAPR] name"
+	},
 	{
-		"destroy", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
-		NULL, "[-v] prov ..."
+		"add", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name prov"
 	},
 	{
-		"clear", G_FLAG_VERBOSE, mp_main, G_NULL_OPTS,
-		NULL, "[-v] prov ..."
+		"remove", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name prov"
 	},
 	{
+		"fail", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name prov"
+	},
+	{
+		"restore", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name prov"
+	},
+	{
 		"rotate", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
-		NULL, "[-v] prov ..."
+		NULL, "[-v] name"
 	},
 	{
 		"getactive", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name"
+	},
+	{
+		"destroy", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name"
+	},
+	{
+		"stop", G_FLAG_VERBOSE, NULL, G_NULL_OPTS,
+		NULL, "[-v] name"
+	},
+	{
+		"clear", G_FLAG_VERBOSE, mp_main, G_NULL_OPTS,
 		NULL, "[-v] prov ..."
 	},
 	G_CMD_SENTINEL
@@ -90,8 +129,6 @@ mp_main(struct gctl_req *req, unsigned int flags _
 	}
 	if (strcmp(name, "label") == 0) {
 		mp_label(req);
-	} else if (strcmp(name, "add") == 0) {
-		mp_add(req);
 	} else if (strcmp(name, "clear") == 0) {
 		mp_clear(req);
 	} else {
@@ -103,13 +140,13 @@ static void
 mp_label(struct gctl_req *req)
 {
 	struct g_multipath_metadata md;
-	off_t disksiz = 0, msize;
-	uint8_t *sector;
+	off_t disksize = 0, msize;
+	uint8_t *sector, *rsector;
 	char *ptr;
 	uuid_t uuid;
 	uint32_t secsize = 0, ssize, status;
-	const char *name, *mpname;
-	int error, i, nargs;
+	const char *name, *name2, *mpname;
+	int error, i, nargs, fd;
 
 	nargs = gctl_get_int(req, "nargs");
 	if (nargs < 2) {
@@ -132,14 +169,14 @@ mp_label(struct gctl_req *req)
 		}
 		if (i == 1) {
 			secsize = ssize;
-			disksiz	= msize;
+			disksize = msize;
 		} else {
 			if (secsize != ssize) {
 				gctl_error(req, "%s sector size %u different.",
 				    name, ssize);
 				return;
 			}
-			if (disksiz != msize) {
+			if (disksize != msize) {
 				gctl_error(req, "%s media size %ju different.",
 				    name, (intmax_t)msize);
 				return;
@@ -155,7 +192,7 @@ mp_label(struct gctl_req *req)
 	md.md_version = G_MULTIPATH_VERSION;
 	mpname = gctl_get_ascii(req, "arg0");
 	strlcpy(md.md_name, mpname, sizeof(md.md_name));
-	md.md_size = disksiz;
+	md.md_size = disksize;
 	md.md_sectorsize = secsize;
 	uuid_create(&uuid, &status);
 	if (status != uuid_s_ok) {
@@ -168,19 +205,12 @@ mp_label(struct gctl_req *req)
 		return;
 	}
 	strlcpy(md.md_uuid, ptr, sizeof (md.md_uuid));
+	md.md_active_active = gctl_get_int(req, "active_active");
+	if (gctl_get_int(req, "active_read"))
+		md.md_active_active = 2;
 	free(ptr);
 
 	/*
-	 * Clear metadata on initial provider first.
-	 */
-	name = gctl_get_ascii(req, "arg1");
-	error = g_metadata_clear(name, NULL);
-	if (error != 0) {
-		gctl_error(req, "cannot clear metadata on %s: %s.", name, strerror(error));
-		return;
-	}
-
-	/*
 	 * Allocate a sector to write as metadata.
 	 */
 	sector = malloc(secsize);
@@ -189,6 +219,12 @@ mp_label(struct gctl_req *req)
 		return;
 	}
 	memset(sector, 0, secsize);
+	rsector = malloc(secsize);
+	if (rsector == NULL) {
+		free(sector);
+		gctl_error(req, "unable to allocate metadata buffer");
+		return;
+	}
 
 	/*
 	 * encode the metadata
@@ -198,6 +234,7 @@ mp_label(struct gctl_req *req)
 	/*
 	 * Store metadata on the initial provider.
 	 */
+	name = gctl_get_ascii(req, "arg1");
 	error = g_metadata_store(name, sector, secsize);
 	if (error != 0) {
 		gctl_error(req, "cannot store metadata on %s: %s.", name, strerror(error));
@@ -205,20 +242,29 @@ mp_label(struct gctl_req *req)
 	}
 
 	/*
-	 * Now add the rest of the providers.
+	 * Now touch the rest of the providers to hint retaste.
 	 */
-	error = gctl_change_param(req, "verb", -1, "add");
-	if (error) {
-		gctl_error(req, "unable to change verb to \"add\": %s.", strerror(error));
-		return;
-	}
 	for (i = 2; i < nargs; i++) {
-		error = gctl_change_param(req, "arg1", -1, gctl_get_ascii(req, "arg%d", i));
-		if (error) {
-			gctl_error(req, "unable to add %s to %s: %s.", gctl_get_ascii(req, "arg%d", i), mpname, strerror(error));
+		name2 = gctl_get_ascii(req, "arg%d", i);
+		fd = g_open(name2, 1);
+		if (fd < 0) {
+			fprintf(stderr, "Unable to open %s: %s.\n",
+			    name2, strerror(errno));
 			continue;
 		}
-		mp_add(req);
+		if (pread(fd, rsector, secsize, disksize - secsize) !=
+		    (ssize_t)secsize) {
+			fprintf(stderr, "Unable to read metadata from %s: %s.\n",
+			    name2, strerror(errno));
+			g_close(fd);
+			continue;
+		}
+		g_close(fd);
+		if (memcmp(sector, rsector, secsize)) {
+			fprintf(stderr, "No metadata found on %s."
+			    " It is not a path of %s.\n",
+			    name2, name);
+		}
 	}
 }
 
@@ -247,13 +293,3 @@ mp_clear(struct gctl_req *req)
 	}
 }
 
-static void
-mp_add(struct gctl_req *req)
-{
-	const char *errstr;
-
-	errstr = gctl_issue(req);
-	if (errstr != NULL && errstr[0] != '\0') {
-		gctl_error(req, "%s", errstr);
-	}
-}
Index: sbin/geom/class/multipath/gmultipath.8
===================================================================
--- sbin/geom/class/multipath/gmultipath.8	(revision 236623)
+++ sbin/geom/class/multipath/gmultipath.8	(working copy)
@@ -24,7 +24,7 @@
 .\"
 .\" $FreeBSD$
 .\"
-.Dd February 26, 2007
+.Dd April 18, 2012
 .Dt GMULTIPATH 8
 .Os
 .Sh NAME
@@ -32,11 +32,52 @@
 .Nd "disk multipath control utility"
 .Sh SYNOPSIS
 .Nm
+.Cm create
+.Op Fl ARv
+.Ar name
+.Ar prov ...
+.Nm
 .Cm label
-.Op Fl hv
+.Op Fl ARv
 .Ar name
 .Ar prov ...
 .Nm
+.Cm configure
+.Op Fl APRv
+.Ar name
+.Nm
+.Cm add
+.Op Fl v
+.Ar name prov
+.Nm
+.Cm remove
+.Op Fl v
+.Ar name prov
+.Nm
+.Cm fail
+.Op Fl v
+.Ar name prov
+.Nm
+.Cm restore
+.Op Fl v
+.Ar name prov
+.Nm
+.Cm rotate
+.Op Fl v
+.Ar name
+.Nm
+.Cm getactive
+.Op Fl v
+.Ar name
+.Nm
+.Cm destroy
+.Op Fl v
+.Ar name
+.Nm
+.Cm stop
+.Op Fl v
+.Ar name
+.Nm
 .Cm clear
 .Op Fl v
 .Ar prov ...
@@ -53,27 +94,92 @@ The
 .Nm
 utility is used for device multipath configuration.
 .Pp
-Only automatic configuration is supported at the present time via the
-.Cm label
-command.
-This operation writes a label on the last sector of the underlying
-disk device with a contained name and UUID.
-The UUID guarantees uniqueness
-in a shared storage environment but is in general too cumbersome to use.
+The multipath device can be configured using two different methods:
+.Dq manual
+or
+.Dq automatic .
+When using the
+.Dq manual
+method, no metadata are stored on the devices, so the multipath
+device has to be configured by hand every time it is needed.
+Additional device paths also won't be detected automatically.
+The
+.Dq automatic
+method uses on-disk metadata to detect device and all it's paths.
+Metadata use the last sector of the underlying disk device and
+include device name and UUID.
+The UUID guarantees uniqueness in a shared storage environment
+but is in general too cumbersome to use.
 The name is what is exported via the device interface.
 .Pp
 The first argument to
 .Nm
 indicates an action to be performed:
 .Bl -tag -width ".Cm destroy"
+.It Cm create
+Create multipath device with
+.Dq manual
+method without writing any on-disk metadata.
+It is up to administrator, how to properly identify device paths.
+Kernel will only check that all given providers have same media and
+sector sizes.
+.Pp
+.Fl A
+option enables Active/Active mode,
+.Fl R
+option enables Active/Read mode, otherwise Active/Passive mode is used
+by default.
 .It Cm label
-Label the given underlying device with the specified
+Create multipath device with
+.Dq automatic
+method.
+Label the first given provider with on-disk metadata using the specified
 .Ar name .
-The kernel module
-.Pa geom_multipath.ko
-will be loaded if it is not loaded already.
+The rest of given providers will be retasted to detect these metadata.
+It reliably protects against specifying unrelated providers.
+Providers with no matching metadata detected will not be added to the device.
+.Pp
+.Fl A
+option enables Active/Active mode,
+.Fl R
+option enables Active/Read mode, otherwise Active/Passive mode is used
+by default.
+.It Cm configure
+Configure the given multipath device.
+.Pp
+.Fl A
+option enables Active/Active mode,
+.Fl P
+option enables Active/Passive mode,
+.Fl R
+option enables Active/Read mode.
+.It Cm add
+Add the given provider as a path to the given multipath device.
+Should normally be used only for devices created with
+.Dq manual
+method, unless you know what you are doing (you are sure that it is another
+device path, but tasting its metadata in regular
+.Dq automatic
+way is not possible).
+.It Cm remove
+Remove the given provider as a path from the given multipath device.
+If the last path removed, the multipath device will be destroyed.
+.It Cm fail
+Mark specified provider as a path of the specified multipath device as failed.
+If there are other paths present, new requests will be forwarded there.
+.It Cm restore
+Mark specified provider as a path of the specified multipath device as
+operational, allowing it to handle requests.
+.It Cm rotate
+Change the active provider/path in Active/Passive mode.
+.It Cm getactive
+Get the currently active provider(s)/path(s).
+.It Cm destroy
+Destroy the given multipath device clearing metadata.
+.It Cm stop
+Stop the given multipath device without clearing metadata.
 .It Cm clear
-Clear metadata on the given device.
+Clear metadata on the given provider.
 .It Cm list
 See
 .Xr geom 8 .
@@ -101,14 +207,15 @@ Debug level of the
 GEOM class.
 This can be set to 0 (default) or 1 to disable or enable various
 forms of chattiness.
+.It Va kern.geom.multipath.exclusive : No 1
+Open underlying providers exclusively, preventing individual paths access.
 .El
 .Sh EXIT STATUS
 Exit status is 0 on success, and 1 if the command fails.
 .Sh MULTIPATH ARCHITECTURE
 .Pp
-This is an active/passive
-multiple path architecture with no device knowledge or presumptions other
-than size matching built in.
+This is a multiple path architecture with no device knowledge or
+presumptions other than size matching built in.
 Therefore the user must exercise some care
 in selecting providers that do indeed represent multiple paths to the
 same underlying disk device.
@@ -133,15 +240,23 @@ of multiple pathnames refer to the same device sho
 system operator who will use tools and knowledge of their own storage
 subsystem to make the correct configuration selection.
 .Pp
-As an active/passive architecture, only one path has I/O moving on it
+There are Active/Passive, Active/Read and Active/Active operation modes
+supported.
+In Active/Passive mode only one path has I/O moving on it
 at any point in time.
 This I/O continues until an I/O is returned with
 a generic I/O error or a "Nonexistent Device" error.
-When this occurs,
-the active device is kicked out of the
-.Nm MULTIPATH
-GEOM class and the next in a list is selected, the failed I/O reissued
-and the system proceeds.
+When this occurs, that path is marked FAIL, the next path
+in a list is selected as active and the failed I/O reissued.
+In Active/Active mode all paths not marked FAIL may handle I/O same time.
+Requests are distributed between paths to equalize load.
+For capable devices it allows to utilize bandwidth of all paths.
+In Active/Read mode all paths not marked FAIL may handle reads same time,
+but unlike Active/Active only one path handles write requests at any
+point in time.
+It allows to closer follow original write request order if above layer
+needs it for data consistency (not waiting for requisite write completion
+before sending dependent write).
 .Pp
 When new devices are added to the system the
 .Nm MULTIPATH
@@ -149,9 +264,9 @@ GEOM class is given an opportunity to taste these
 If a new
 device has a
 .Nm MULTIPATH
-label, the device is used to either create a new
+on-disk metadata label, the device is used to either create a new
 .Nm MULTIPATH
-GEOM, or to attach to the end of the list of devices for an existing
+GEOM, or been added the list of paths for an existing
 .Nm MULTIPATH
 GEOM.
 .Pp
@@ -176,7 +291,7 @@ of an RSCN event from the Fabric Domain Controller
 a rescan to occur and cause the attachment and configuration of any
 (now) new devices to occur, causing the taste event described above.
 .Pp
-This means that this active/passive architecture is not a one-shot path
+This means that this multipath architecture is not a one-shot path
 failover, but can be considered to be steady state as long as failed
 paths are repaired (automatically or otherwise).
 .Pp
@@ -184,7 +299,7 @@ Automatic rescanning is not a requirement.
 Nor is Fibre Channel.
 The
 same failover mechanisms work equally well for traditional "Parallel"
-SCSI but require manual intervention with
+SCSI but may require manual intervention with
 .Xr camcontrol 8
 to cause the reattachment of repaired device links.
 .Sh EXAMPLES
@@ -226,9 +341,9 @@ mount /dev/multipath/FREDa /mnt....
 .Pp
 The resultant console output looks something like:
 .Bd -literal -offset indent
-GEOM_MULTIPATH: adding da0 to Fred/b631385f-c61c-11db-b884-0011116ae789
-GEOM_MULTIPATH: da0 now active path in Fred
-GEOM_MULTIPATH: adding da2 to Fred/b631385f-c61c-11db-b884-0011116ae789
+GEOM_MULTIPATH: da0 added to FRED
+GEOM_MULTIPATH: da0 is now active path in FRED
+GEOM_MULTIPATH: da2 added to FRED
 .Ed
 .Sh SEE ALSO
 .Xr geom 4 ,
@@ -240,24 +355,6 @@ The resultant console output looks something like:
 .Xr mount 8 ,
 .Xr newfs 8 ,
 .Xr sysctl 8
-.Sh BUGS
-The
-.Nm
-should allow for a manual method of pairing disks.
-.Pp
-There is currently no way for
-.Pa geom_multipath.ko
-to distinguish between various label instances of the same provider.
-That
-is devices such as
-.Ar da0
-and
-.Ar da0c
-can be tasted and instantiated as multiple paths for the same device.
-Technically, this is correct, but pretty useless.
-This will be fixed soon
-(I hope), but to avoid this it is a good idea to destroy any label on
-the disk object prior to labelling it with
-.Nm .
 .Sh AUTHOR
 .An Matthew Jacob Aq mjacob@FreeBSD.org
+.An Alexander Motin Aq mav@FreeBSD.org
Index: sys/geom
===================================================================
--- sys/geom	(revision 236623)
+++ sys/geom	(working copy)

Property changes on: sys/geom
___________________________________________________________________
Added: svn:mergeinfo
   Merged /user/piso/ipfw/sys/geom:r190918,190921,190923,190926
   Merged /stable/8/sys/sys/geom:r211823
   Merged /head/sys/geom:r196118,196121-196122,196129,196132,196135,196141-196142,196149-196150,196152,196159,196162,196174,196176,196179,196193,196196,196200-196201,196203-196206,196224,196226,196228-196230,196234,196246,196256,196260,196263,196267-196269,196274,196276,196289,196291,196293,196295,196297,196299,196301,196303,196307,196309,196316,196318,196326,196332-196334,196342,196352-196353,196358,196364,196366,196368,196370,196372,196376,196378,196380,196386,196388,196390,196395,196397,196403-196404,196410,196412,196415,196417,196419,196423,196435,196455-196458,196460,196464-196466,196470-196471,196481-196482,196487-196498,196501-196505,196507,196509-196510,196512,196516-196520,196524,196529,196531-196536,196543,196547,196551,196553,196556,196559-196560,196567-196569,196579-196580,196592,196608-196610,196615,196633,196635-196637,196640,196643-196644,196648-196649,196653,196655-196657,196659-196660,196662,196678,196689,196692,196702-196705,196707,196714,196717,196721,196730,196733,196738-196739,196745,196762,196769,196771-196772,196777,196785,196796-196798,196809,196811,196822-196824,196826,196829,196835,196837,196840,196844,196863-196865,196871,196879,196885,196887-196889,196891,196893,196897-196898,196900-196901,196903-196904,196907,196919-196921,196927,196932,196941,196943-196944,196947,196949,196953-196954,196964-196966,196978-196980,196982-196983,196985,196987,196993,197009,197011,197017-197019,197021-197022,197025,197030-197031,197039-197040,197043,197046,197048-197049,197062,197070,197073-197074,197077-197080,197082,197084-197085,197099,197104-197105,197107,197109,197128-197133,197150-197156,197164,197167,197172-197174,197176-197177,197185,197190,197193,197195,197201-197203,197208,197210,197212,197214,197218-197219,197223-197225,197227,197235,197240-197243,197257,197260-197263,197269,197286-197289,197293-197294,197306,197316-197317,197323,197325-197328,197331,197334,197341-197342,197348,197350-197351,197364,197372-197373,197379-197381,197383-197384,197386-197391,197395,197397,197399,197401-197403,197405-197407,197410,197413,197415-197416,197420-197421,197424,197426,197428,197433,197435,197438-197439,197442,197444,197449-197450,197455,197458-197469,197475-197476,197478,197490,197493,197496-197497,197501,197504,197512-197515,197518,197525,197535,197540-197541,197553-197556,197558-197559,197561-197573,197579-197581,197583-197592,197600,197603-197606,197608,197611,197624,197627,197636,197640-197641,197643-197645,197647-197650,197654,197657-197663,197680,197682-197683,197687-197688,197692,197695-197696,197709,197711,197720-197721,197726-197727,197729-197730,197735,197761,197772,197783,197789,197791,197795,197803,197814,197816,197824,197831-197832,197837-197838,197841-197843,197850,197856,197860-197861,197863,197868,197896,197898,197910,197914,197928-197930,197932-197934,197942,197945,197948,197950-197952,197955,197961-197963,197975-197977,197997,197999,198020,198043,198049-198050,198075-198076,198079,198097-198099,198111,198126,198134,198149,198151-198153,198170,198174,198185,198194,198196,198198,198201-198203,198212-198213,198218-198219,198223,198230,198233,198237,198242,198250-198252,198257-198260,198262,198271,198277,198279,198289-198291,198295,198301,198303,198306-198307,198318-198322,198327-198328,198331-198333,198338,198341-198343,198346,198353,198356,198366-198367,198369,198372-198373,198377-198378,198381-198382,198384-198385,198389-198391,198393-198394,198400,198407,198411,198417-198423,198426-198429,198431-198432,198438-198439,198444-198445,198452,198464,198467-198468,198472,198475-198476,198479-198483,198486-198488,198499,198502,198505-198508,198519-198520,198522,198525,198537,198539,198541,198546,198554,198581-198583,198587-198588,198590,198593,198617,198621,198623,198670,198678,198684,198691-198692,198694-198697,198700,198703,198705,198708,198717-198719,198723-198725,198731,198733,198748,198752,198774-198776,198782,198786,198813-198814,198816,198818-198819,198822,198832,198845,198849,198851-198853,198857-198858,198862,198865-198868,198896-198897,198899,198904-198905,198911,198923-198924,198927-198928,198931,198940,198945,198947,198950,198952,198964,198967-198968,198976,198988,198990,198993,198996-198997,199002,199007-199012,199014-199018,199020,199035-199037,199043,199050,199053-199054,199057-199062,199065,199067,199069,199073-199074,199084,199086,199108,199114-199116,199132,199135-199137,199151,199153,199156-199157,199169,199173,199176,199178,199184,199186-199187,199192-199193,199208-199210,199215,199219,199223,199225-199230,199232,199237-199241,199253,199258-199260,199262-199263,199268-199269,199273-199274,199278-199281,199284,199287,199321-199322,199332-199333,199337-199338,199355,199365,199369-199374,199413,199418,199437,199442,199459,199477,199491,199502,199518,199522-199523,199525-199529,199533-199535,199543,199548-199553,199556,199558,199561,199563-199566,199574,199576,199579-199580,199602,199608-199613,199616-199617,199645-199646,199661-199668,199670-199680,199714-199715,199717-199718,199727,199734,199747,199749,199761-199764,199798-199799,199807-199808,199814,199816,199821-199822,199827,199829,199846,199852,199866,199875,199883-199888,199893-199897,199899,199904-199906,199941,199946-199949,199959-199960,199968-199969,199972,199974,199997,200001,200003,200008,200014,200018,200026-200028,200033,200036-200037,200045,200051-200053,200055,200058,200060,200064,200082-200084,200086-200089,200091,200102,200107,200109-200111,200117,200121,200124-200126,200129,200158,200162,200171,200180,200182,200196,200200,200207,200215-200219,200223,200227-200228,200230,200239-200243,200246,200251,200253-200255,200264,200268,200272-200273,200275,200280,200287-200288,200291,200295,200304-200310,200346,200352-200353,200357,200359,200375,200395-200397,200414,200422,200444,200447,200459,200471,200473,200481-200482,200484-200485,200514,200519-200536,200538-200541,200543-200545,200548,200551-200555,200557-200558,200572,200584,200591,200594,200602,200607,200609,200613,200615-200617,200631,200635,200637-200639,200644,200652-200653,200655,200657-200658,200666-200669,200671,200693,200696,200723-200724,200726-200727,200739-200740,200753-200754,200756,200758-200759,200764,200770,200776,200796,200798,200801,200803-200804,200808,200810,200814-200817,200820-200827,200829,200845,200847,200853-200854,200856-200857,200865,200871-200880,200884-200889,200891,200899,200904-200908,200910-200918,200920-200926,200930,200933-200935,200938,200940,200942,200944-200948,200950,200955,200965-200966,200969,200972,200976-200977,200987,200991,200993-200995,200999-201000,201003-201005,201008-201009,201021,201023,201028-201029,201031-201032,201044,201052,201071,201126,201131,201134,201138-201139,201143,201145,201148,201151,201196,201199-201200,201209,201217,201222,201234,201236,201254,201261,201264,201269,201282,201284-201285,201318-201319,201325,201339-201340,201342,201345,201347,201349-201352,201371,201373-201374,201395-201396,201406,201408,201410,201415-201416,201430,201438-201439,201442-201443,201446,201523,201532,201543-201545,201566-201567,201620,201644-201645,201680-201681,201684,201688-201690,201701,201703,201709-201710,201714,201742,201756,201758,201766-201769,201790,201793,201797,201801,201813-201814,201818,201822,201848,201853,201879,201882-201883,201890,201895-201896,201898-201899,201901,201905-201917,201921,201924,201932,201941,201953-201955,201966,201976-201979,201984-201986,201990,201993,201995,202000,202003,202006,202010-202011,202019,202023,202027-202041,202044,202046,202054,202056-202057,202061,202063-202066,202085,202089-202092,202097,202105,202116,202119-202121,202123,202127,202129,202143,202150,202156,202161,202163,202166,202170-202173,202175,202181,202243,202267-202273,202286,202290,202293-202294,202341-202342,202364,202376,202387,202406,202418,202441,202448-202449,202454,202468-202469,202516-202518,202520-202521,202523,202526,202528-202529,202534,202552,202558,202567,202587-202588,202608-202609,202611-202612,202671,202678,202692,202697-202699,202717,202723,202732,202736,202767,202771,202773-202774,202782-202783,202785-202786,202789,202796-202797,202806,202809,202812,202821-202822,202826-202827,202830-202834,202839,202849-202850,202863-202865,202867,202870,202881-202882,202889,202894,202898,202900,202903-202905,202908-202909,202915,202917,202919,202931,202934-202935,202939-202940,202954,202964,202967,202971,202973,202975-202977,202983-202986,202996-203001,203007-203011,203024,203030,203033-203034,203043,203049-203052,203054,203058,203061-203062,203070,203072,203075-203076,203078,203080-203083,203085,203087,203090,203094,203106,203108,203112-203116,203119,203123,203128-203130,203132,203134,203137-203146,203148-203152,203156,203158-203160,203165,203175,203177,203179-203180,203185,203261,203272,203289,203303,203319-203320,203334-203335,203341,203347,203350,203352,203354-203355,203358,203360,203367,203376,203384-203386,203401,203408,203410,203414-203415,203421-203422,203426,203430,203444-203445,203449,203451,203453,203455,203463,203474,203476-203478,203483-203484,203489,203499,203503-203504,203506-203511,203524-203525,203528-203530,203533,203535,203546,203548,203556,203572,203622,203629,203637,203673,203678-203680,203682-203683,203685,203691,203693,203695-203697,203708,203716,203724,203727-203729,203731-203732,203743,203745-203746,203750-203751,203754,203763,203776,203783,203785,203788,203796,203801,203810,203813,203818,203822,203826-203831,203833-203834,203838-203839,203843-203844,203846-203849,203866,203870,203873,203875,203882-203885,203896,203899,203903,203905-203906,203924,203930-203931,203933-203936,203940,203944-203945,203959,203968,203985,204009,204019,204031,204040,204042,204050-204052,204054-204056,204060,204067,204071,204073,204076,204081-204082,204093,204096,204101-204102,204105-204106,204108-204109,204111,204127-204131,204135-204137,204140-204147,204149,204151-204153,204155-204159,204164,204173,204175,204179-204180,204182-204185,204195,204197,204205,204210,204212,204216,204218-204220,204222-204223,204225,204228,204230,204235-204236,204242,204248-204250,204253,204256-204257,204264-204265,204268-204271,204274,204278-204279,204281,204283,204296-204297,204305,204309,204313,204315-204317,204319,204326-204328,204348,204351,204353-204354,204356,204361-204363,204365-204368,204370-204374,204376-204378,204384-204385,204397,204402,204408,204410,204412-204413,204415,204420,204425,204430,204436-204437,204462-204476,204498,204509,204518,204521,204533,204539-204542,204545,204557,204576-204579,204581,204589-204590,204611,204617,204633,204635,204638,204641,204644,204646-204648,204656-204657,204662,204666,204670,204675,204689-204690,204692,204694,204719,204753,204764,204773,204776-204778,204788-204789,204804-204807,204809-204810,204826,204830,204838,204874,204877-204878,204901-204905,204907,204913,204916,204920-204923,204941,204955,204957,204965,204972,204975,204978-204979,204981,204983,204989-204990,204992,204997,205003,205005,205010,205013-205015,205024,205026-205036,205038-205040,205042-205043,205047-205049,205061,205064,205066,205069,205072,205074-205075,205077,205079-205080,205082-205083,205092-205093,205095-205097,205102,205104,205115,205120,205126,205132-205134,205140-205141,205158,205160-205161,205163,205167,205172,205197,205210,205214,205222-205223,205231,205234,205236,205251-205255,205258,205263-205264,205268-205269,205276,205279,205297,205299-205300,205316-205327,205332,205334,205345-205347,205356-205358,205360-205361,205363-205364,205370,205385,205399,205402,205409,205411-205413,205422,205428-205429,205431-205435,205444,205448,205452,205454-205455,205488,205495,205497,205502,205506,205516,205527,205534-205536,205550,205557-205558,205562,205564,205566,205569,205572-205573,205576,205604-205605,205626-205629,205637,205647,205649-205653,205661-205663,205665,205675,205678,205680-205681,205694,205698,205712-205713,205720,205723,205726-205727,205734,205778,205789,205791,205801-205805,205838,205845,205847,205851,205858,205860,205863,205865,205869,205884-205886,205904,205919,205932,205941,205944-205950,205959,205967,205986-205987,205993,205998-206001,206015,206017-206021,206023,206026-206029,206032,206049-206051,206053-206054,206061,206063,206081,206086,206089,206093-206094,206097-206098,206109,206117,206128-206130,206137,206151,206160,206170,206174,206206,206210,206236,206264,206268,206281,206358,206360,206364,206367,206369-206372,206384,206388,206395,206398,206400,206403-206405,206409,206415-206421,206426,206429-206431,206433,206436-206437,206443-206450,206452,206454,206456,206459-206460,206469-206470,206474-206477,206480-206482,206486,206488,206540,206544-206547,206551,206553,206563,206582,206584,206595,206604,206614,206617,206623,206625,206629,206632,206637-206639,206648,206650-206652,206659,206662,206665,206667,206671-206672,206684,206688,206690,206695,206705,206712-206718,206721,206746,206749,206758,206761,206763-206768,206770,206792-206797,206801,206803,206814,206818-206819,206829,206834,206836-206838,206840,206844,206859,206876,206878-206880,206891-206892,206894-206895,206897,206900-206902,206909,206916,206922,206989,206992-206993,207001,207007-207008,207016,207020,207027,207068,207071,207077-207080,207082,207089,207094,207099,207116,207130-207131,207134,207139,207152,207170,207176,207178,207181,207191,207194-207195,207197,207207,207221-207223,207240-207243,207248,207251,207268-207269,207275-207278,207281-207282,207285-207287,207303,207305-207306,207322-207323,207329-207331,207334-207335,207337,207344,207349-207350,207355,207359-207360,207362-207366,207369,207375-207377,207379-207380,207391,207404,207409,207411,207426-207428,207430-207433,207441-207442,207445-207446,207463,207468,207473-207475,207480-207481,207484,207490,207499-207500,207511,207532-207533,207536-207537,207543,207545,207554,207569-207570,207572,207579-207580,207585,207600,207602-207603,207605-207606,207620,207622-207626,207628,207630,207635,207638-207639,207643,207645,207651-207652,207659,207670-207671,207673,207676,207680,207683,207687-207688,207692,207696,207709,207729,207748,207750,207761,207763-207764,207768,207785,207832,207847-207848,207851-207852,207877-207878,207885,207908-207911,207920-207922,207924-207926,207929,207933-207934,207936-207938,207956-207958,207963,207966,207970,207979,207983,207985,208006-208019,208022,208026,208030,208036,208047-208048,208050,208052,208081-208084,208097,208100-208103,208117,208119-208120,208129-208131,208142-208143,208147-208150,208152,208159-208160,208162,208165-208168,208172-208173,208183,208212,208234,208249-208250,208253-208254,208265,208276,208279,208282,208285,208293,208300,208309,208312,208340,208348-208350,208356,208362,208364,208369-208375,208379,208388,208390-208393,208405,208410-208414,208422,208436,208438,208442-208443,208452-208455,208458,208468,208472,208474,208479-208480,208488,208507-208509,208512,208514-208515,208532-208533,208542-208543,208548,208553-208556,208563-208567,208581,208587,208589,208601,208603-208605,208607-208608,208610,208616,208621,208632-208634,208638-208639,208642-208644,208650,208659,208669-208672,208683,208689,208696-208697,208699,208703,208711-208712,208717,208722,208731,208742-208744,208746,208752,208761-208762,208770,208773,208775-208777,208787,208794,208796,208800,208806,208808-208809,208813-208814,208816-208820,208822-208823,208833-208837,208839,208841-208842,208849,208852-208857,208861-208864,208866,208870,208874-208879,208883,208887,208891,208895,208897,208901-208902,208905,208907,208912,208915,208917-208918,208920-208922,208925,208946-208947,208951-208953,208969-208970,208982-208983,208989,208991,208994,209013,209016,209022,209026,209029,209050,209053,209055-209056,209060,209062,209064-209065,209068,209070-209071,209085,209092-209101,209104-209106,209114-209116,209119-209120,209138,209144,209154-209155,209169,209174,209178,209186-209189,209191,209193-209194,209196-209198,209204,209208,209212-209213,209218,209222,209230,209237-209238,209241-209244,209247,209252,209256,209258-209261,209268,209275,209289,209313-209314,209318,209325,209328-209330,209338,209340-209341,209361,209367,209369,209407,209425,209443-209445,209447,209450,209452,209454,209460-209463,209466,209470,209482-209483,209490,209492,209494,209499-209500,209502,209512,209523,209536,209540-209541,209548-209549,209577,209590,209592,209595,209597-209599,209605,209611,209616,209639,209644-209646,209648,209650,209662-209664,209669,209682-209683,209685-209688,209695,209697,209702,209714,209718,209723,209737,209740-209744,209746-209747,209761,209769,209789,209793,209797,209802,209805-209812,209814-209816,209818,209836,209839-209841,209844-209845,209853,209859-209860,209862,209865-209866,209872,209883-209884,209887-209888,209892,209902,209907,209917-209918,209928-209930,209934-209935,209944,209946,209948-209950,209955-209957,209959-209963,209965-209968,209977-209978,209980-209982,209987,209994,209996,210003,210005,210007,210009,210011-210015,210018,210026-210030,210032,210034,210038-210039,210041,210046,210055,210066,210083,210096,210098-210100,210102,210104-210105,210107-210111,210113-210114,210117,210124,210126,210129,210135-210137,210142,210149-210150,210152,210154-210155,210157-210159,210161,210165,210168,210176,210178,210184,210201,210203,210227,210244,210248,210257,210259-210261,210263,210267-210271,210275,210282,210286,210294,210311-210312,210317,210327,210350,210358,210369,210383,210393,210398,210401,210409,210422-210423,210427-210428,210443,210446,210452,210454-210455,210457,210460,210469-210470,210493-210495,210500,210505,210514-210521,210524,210529,210532-210534,210537,210543,210549,210553,210556,210569,210571,210575-210577,210595-210596,210599-210600,210604-210606,210614-210615,210621,210623-210627,210630-210631,210638,210644,210661,210665,210686,210698-210699,210703,210714,210746-210747,210774,210777,210779-210780,210782-210783,210786,210792,210795-210796,210804-210805,210810,210833-210834,210837,210839,210845-210848,210866,210900,210904,210910-210911,210913-210914,210918,210921-210926,210931,210935,210939-210940,210942,210947,210968,210976-210977,210986,210999,211005-211006,211021-211022,211030,211046-211053,211059,211063,211068,211071,211073,211083,211087,211089,211091,211103-211105,211111,211115,211117,211149,211151,211153,211157,211159,211167,211191,211193-211194,211197,211201-211202,211213,211215-211218,211229,211236,211249,211270,211280,211283,211285,211292,211295,211301,211314-211317,211327,211333,211335,211339,211345-211347,211396,211400,211424,211433,211435,211440,211445,211447-211449,211451,211453,211455,211462,211464,211476-211482,211497-211498,211502-211504,211509-211511,211513,211518,211530,211546,211555,211568,211594,211596,211598,211648,211670-211671,211684,211716-211717,211721,211741,211762,211764-211768,211789,211802,211809,211811-211812,211814,211818,211820-211821,211830,211854-211855,211861-211862,211868,211874,211888,211893,211904,211906-211907,211909,211913,211920,211922-211923,211927,211931-211932,211941,211944,211946-211948,211950-211951,211953,211958,211967,211969,211991-211992,211994,211996,211998,212008,212026,212028,212043-212045,212047,212054,212058,212061,212063,212065-212066,212069,212071,212075,212081,212096,212099-212100,212102-212105,212109,212113,212116-212117,212119-212124,212126-212136,212145-212146,212148,212152-212153,212155-212158,212160,212165-212167,212172,212185,212209-212210,212213,212216-212217,212224-212225,212240,212242,212248,212251,212256,212265-212266,212278,212281-212285,212292-212293,212302,212305-212307,212321-212322,212324-212326,212331,212338,212342,212347,212359-212360,212362-212363,212366,212368,212380,212382-212385,212387,212403,212407,212409-212410,212413,212436,212439,212443,212456-212457,212499,212501,212506,212532,212544,212549-212550,212553,212560,212589,212593-212594,212605,212609,212611,212618-212621,212628,212632-212634,212647,212650,212654-212655,212657,212661,212663,212676,212694,212699,212702-212707,212709-212714,212723,212725,212729-212730,212732,212754-212756,212758-212759,212761,212763-212764,212770,212773-212777,212780-212784,212790,212799-212801,212806,212809,212821,212824,212830,212833-212834,212842-212845,212850-212851,212853-212855,212861,212868,212873,212896-212897,212902,212906,212926,212950-212951,212957,212964,212968-212969,212971-212972,212974,212980,212989,212991,212993-212994,212998,213000,213028,213047,213055,213062-213070,213072,213080-213081,213089-213090,213092,213101,213103-213105,213133,213135-213136,213140,213147,213150,213156,213158,213162,213164-213166,213174,213188,213197-213199,213225-213226,213228-213230,213236,213239-213240,213246,213254-213255,213258,213265,213268,213271-213272,213278,213280,213283,213286,213301,213303-213307,213316,213321-213323,213325,213328,213333-213335,213340-213342,213345-213346,213354,213359-213361,213364,213377,213379,213382,213384-213385,213408-213411,213423-213427,213431-213432,213435-213439,213441,213443,213448,213452,213455-213456,213461,213464-213465,213468,213474-213475,213480-213481,213484-213486,213495,213508-213509,213522,213527-213528,213536-213537,213543-213544,213575,213578,213587,213634,213648,213651,213664,213673,213696,213710-213712,213716-213717,213729-213730,213735,213737-213738,213742,213747,213755-213756,213762,213772,213778,213783,213787,213796-213797,213802-213809,213812,213814,213832,213836-213837,213842,213844,213846,213856-213857,213861,213864,213868-213869,213871-213873,213876,213878-213880,213893-213894,213896,213908,213910,213912-213913,213916,213929-213932,213937,213986,214016,214021,214026,214048-214049,214053,214056,214062,214069-214070,214077,214087,214089,214095,214099,214102,214106-214107,214116,214118,214125,214130,214133,214136,214149,214160,214162-214163,214181,214203,214216,214219,214224-214229,214236,214245,214250-214251,214255,214258,214262-214264,214279,214288,214292,214302-214303,214325,214333,214346-214347,214349,214352,214373,214378,214380,214386,214390,214406,214418,214427-214428,214444,214446,214448-214449,214457,214493-214495,214511,214513,214515-214516,214526,214528,214542,214564-214566,214575,214584,214601,214605-214606,214608,214610,214672,214676,214681-214682,214686,214708,214726,214754,214765-214766,214774,214782,214798,214800,214804,214840-214842,214844,214846,214848-214849,214851-214852,214854,214876-214877,214879-214880,214894,214896,214898-214899,214903,214913,214918,214928,214933,214938-214939,214953,214965,214988,214992,214998-214999,215001,215014,215017-215020,215025,215034-215035,215039,215068,215085,215093,215095,215100-215102,215104,215110,215128,215131-215135,215152-215153,215183,215194,215198-215199,215234,215241,215244,215258,215260,215280-215285,215289,215295,215297-215298,215300-215302,215304-215305,215307,215309,215321,215325-215330,215334,215338-215339,215348-215350,215353,215355,215397-215398,215401,215410,215418-215420,215423,215427-215428,215431,215453-215454,215459,215468-215472,215508,215525,215544,215548,215552-215553,215559,215574,215576,215610,215641,215663,215665,215673,215677,215681-215683,215686,215699,215703,215707-215708,215711,215713-215714,215716,215720-215722,215726,215732,215734,215741-215742,215753-215754,215758,215768,215779,215782,215796-215797,215800,215811,215813,215819-215821,215838,215843-215844,215847-215850,215864-215865,215905-215906,215923,215942,215951,215973,216012,216022,216041,216084,216111,216120,216149-216150,216158-216159,216171-216173,216176,216188,216192,216194-216195,216231,216237-216238,216241,216249,216253,216255,216277,216280,216309,216330,216335,216355,216364-216365,216371,216382,216385,216394,216397,216454,216480,216495,216502,216504,216521-216523,216557,216572,216679,216691,216703,216762,216790,216812,216824,216843-216848,216891-216892,216919,216940,217127,217169,217226,217242,217295-217296,217415,217511,217548,217587,217591,217593,217705-217707,217727,218271
   Merged /stable/8/sys/geom:r217050-217053,217055-217056,217408,217553,217710-217713,217795-217797,221756,229308-229309,234917,235387
   Merged /user/thompsa/usb/sys/geom:r187190
   Merged /user/dfr/xenhvm/6/sys/geom:r189304,189451
   Merged /user/peter/kinfo/sys/geom:r185413-185547
   Merged /user/dfr/xenhvm/7/sys/geom:r188574-189614
   Merged /user/luigi/ipfw3-r8/sys/geom:r204833-205453
   Merged /user/mav/ata/sys/geom:r189793-190578
   Merged /projects/cambria/sys/geom:r186008-186350
   Merged /user/piso/sys/geom:r186543,186723,186725-186726,186742,186770-186771,186774,186777-186779,187984-187985,190555,190572,190589,190592,190614,190625,190830
Index: sys/geom/sched/g_sched.c
===================================================================
--- sys/geom/sched/g_sched.c	(revision 236623)
+++ sys/geom/sched/g_sched.c	(working copy)
@@ -1004,11 +1004,6 @@ g_sched_create(struct gctl_req *req, struct g_clas
 
 	gp = g_new_geomf(mp, name);
 	dstgp = proxy ? pp->geom : gp; /* where do we link the provider */
-	if (gp == NULL) {
-		gctl_error(req, "Cannot create geom %s.", name);
-		error = ENOMEM;
-		goto fail;
-	}
 
 	sc = g_malloc(sizeof(*sc), M_WAITOK | M_ZERO);
 	sc->sc_gsched = gsp;
@@ -1034,23 +1029,10 @@ g_sched_create(struct gctl_req *req, struct g_clas
 	gp->dumpconf = g_sched_dumpconf;
 
 	newpp = g_new_providerf(dstgp, gp->name);
-	if (newpp == NULL) {
-		gctl_error(req, "Cannot create provider %s.", name);
-		error = ENOMEM;
-		goto fail;
-	}
-
 	newpp->mediasize = pp->mediasize;
 	newpp->sectorsize = pp->sectorsize;
 
 	cp = g_new_consumer(gp);
-	if (cp == NULL) {
-		gctl_error(req, "Cannot create consumer for %s.",
-		    gp->name);
-		error = ENOMEM;
-		goto fail;
-	}
-
 	error = g_attach(cp, proxy ? newpp : pp);
 	if (error != 0) {
 		gctl_error(req, "Cannot attach to provider %s.",
@@ -1076,24 +1058,16 @@ fail:
 			g_detach(cp);
 		g_destroy_consumer(cp);
 	}
-
 	if (newpp != NULL)
 		g_destroy_provider(newpp);
-
-	if (sc && sc->sc_hash) {
+	if (sc->sc_hash)
 		g_sched_hash_fini(gp, sc->sc_hash, sc->sc_mask,
 		    gsp, sc->sc_data);
-	}
-
-	if (sc && sc->sc_data)
+	if (sc->sc_data)
 		gsp->gs_fini(sc->sc_data);
+	g_free(gp->softc);
+	g_destroy_geom(gp);
 
-	if (gp != NULL) {
-		if (gp->softc != NULL)
-			g_free(gp->softc);
-		g_destroy_geom(gp);
-	}
-
 	return (error);
 }
 
Index: sys/geom/multipath/g_multipath.h
===================================================================
--- sys/geom/multipath/g_multipath.h	(revision 236623)
+++ sys/geom/multipath/g_multipath.h	(working copy)
@@ -43,10 +43,15 @@
 #ifdef	_KERNEL
 
 struct g_multipath_softc {
-	struct g_provider *	pp;
-	struct g_consumer *	cp_active;
+	struct g_provider *	sc_pp;
+	struct g_consumer *	sc_active;
+	struct mtx		sc_mtx;
 	char			sc_name[16];
 	char			sc_uuid[40];
+	int			sc_opened;
+	int			sc_stopping;
+	int			sc_ndisks;
+	int			sc_active_active; /* Active/Active mode */
 };
 #endif	/* _KERNEL */
 
@@ -57,6 +62,7 @@ struct g_multipath_metadata {
 	uint32_t	md_version;	/* version */
 	uint32_t	md_sectorsize;	/* sectorsize of provider */
 	uint64_t	md_size;	/* absolute size of provider */
+	uint8_t		md_active_active; /* Active/Active mode */
 };
 
 static __inline void
@@ -79,6 +85,8 @@ multipath_metadata_encode(const struct g_multipath
 	le32enc(data, md->md_sectorsize);
 	data += sizeof(md->md_sectorsize);
 	le64enc(data, md->md_size);
+	data += sizeof(md->md_size);
+	*data = md->md_active_active;
 }
 
 static __inline void
@@ -95,5 +103,7 @@ multipath_metadata_decode(u_char *data, struct g_m
 	md->md_sectorsize = le32dec(data);
 	data += sizeof(md->md_sectorsize);
 	md->md_size = le64dec(data);
+	data += sizeof(md->md_size);
+	md->md_active_active = *data;
 }
 #endif	/* _G_MULTIPATH_H_ */
Index: sys/geom/multipath/g_multipath.c
===================================================================
--- sys/geom/multipath/g_multipath.c	(revision 236623)
+++ sys/geom/multipath/g_multipath.c	(working copy)
@@ -1,4 +1,5 @@
 /*-
+ * Copyright (c) 2011 Alexander Motin <mav@FreeBSD.org>
  * Copyright (c) 2006-2007 Matthew Jacob <mjacob@FreeBSD.org>
  * All rights reserved.
  *
@@ -51,6 +52,9 @@ SYSCTL_NODE(_kern_geom, OID_AUTO, multipath, CTLFL
 static u_int g_multipath_debug = 0;
 SYSCTL_UINT(_kern_geom_multipath, OID_AUTO, debug, CTLFLAG_RW,
     &g_multipath_debug, 0, "Debug level");
+static u_int g_multipath_exclusive = 1;
+SYSCTL_UINT(_kern_geom_multipath, OID_AUTO, exclusive, CTLFLAG_RW,
+    &g_multipath_exclusive, 0, "Exclusively open providers");
 
 static enum {
 	GKT_NIL,
@@ -77,6 +81,7 @@ static g_taste_t g_multipath_taste;
 static g_ctl_req_t g_multipath_config;
 static g_init_t g_multipath_init;
 static g_fini_t g_multipath_fini;
+static g_dumpconf_t g_multipath_dumpconf;
 
 struct g_class g_multipath_class = {
 	.name		= G_MULTIPATH_CLASS_NAME,
@@ -88,35 +93,145 @@ struct g_class g_multipath_class = {
 	.fini		= g_multipath_fini
 };
 
-#define	MP_BAD		0x1
-#define	MP_POSTED	0x2
+#define	MP_FAIL		0x00000001
+#define	MP_LOST		0x00000002
+#define	MP_NEW		0x00000004
+#define	MP_POSTED	0x00000008
+#define	MP_BAD		(MP_FAIL | MP_LOST | MP_NEW)
+#define MP_IDLE		0x00000010
+#define MP_IDLE_MASK	0xfffffff0
 
+static int
+g_multipath_good(struct g_geom *gp)
+{
+	struct g_consumer *cp;
+	int n = 0;
+
+	LIST_FOREACH(cp, &gp->consumer, consumer) {
+		if ((cp->index & MP_BAD) == 0)
+			n++;
+	}
+	return (n);
+}
+
 static void
+g_multipath_fault(struct g_consumer *cp, int cause)
+{
+	struct g_multipath_softc *sc;
+	struct g_consumer *lcp;
+	struct g_geom *gp;
+
+	gp = cp->geom;
+	sc = gp->softc;
+	cp->index |= cause;
+	if (g_multipath_good(gp) == 0 && sc->sc_ndisks > 0) {
+		LIST_FOREACH(lcp, &gp->consumer, consumer) {
+			if (lcp->provider == NULL ||
+			    (lcp->index & (MP_LOST | MP_NEW)))
+				continue;
+			if (sc->sc_ndisks > 1 && lcp == cp)
+				continue;
+			printf("GEOM_MULTIPATH: "
+			    "all paths in %s were marked FAIL, restore %s\n",
+			    sc->sc_name, lcp->provider->name);
+			lcp->index &= ~MP_FAIL;
+		}
+	}
+	if (cp != sc->sc_active)
+		return;
+	sc->sc_active = NULL;
+	LIST_FOREACH(lcp, &gp->consumer, consumer) {
+		if ((lcp->index & MP_BAD) == 0) {
+			sc->sc_active = lcp;
+			break;
+		}
+	}
+	if (sc->sc_active == NULL) {
+		printf("GEOM_MULTIPATH: out of providers for %s\n",
+		    sc->sc_name);
+	} else if (sc->sc_active_active != 1) {
+		printf("GEOM_MULTIPATH: %s is now active path in %s\n",
+		    sc->sc_active->provider->name, sc->sc_name);
+	}
+}
+
+static struct g_consumer *
+g_multipath_choose(struct g_geom *gp, struct bio *bp)
+{
+	struct g_multipath_softc *sc;
+	struct g_consumer *best, *cp;
+
+	sc = gp->softc;
+	if (sc->sc_active_active == 0 ||
+	    (sc->sc_active_active == 2 && bp->bio_cmd != BIO_READ))
+		return (sc->sc_active);
+	best = NULL;
+	LIST_FOREACH(cp, &gp->consumer, consumer) {
+		if (cp->index & MP_BAD)
+			continue;
+		cp->index += MP_IDLE;
+		if (best == NULL || cp->private < best->private ||
+		    (cp->private == best->private && cp->index > best->index))
+			best = cp;
+	}
+	if (best != NULL)
+		best->index &= ~MP_IDLE_MASK;
+	return (best);
+}
+
+static void
 g_mpd(void *arg, int flags __unused)
 {
+	struct g_geom *gp;
+	struct g_multipath_softc *sc;
 	struct g_consumer *cp;
+	int w;
 
 	g_topology_assert();
 	cp = arg;
-	if (cp->acr > 0 || cp->acw > 0 || cp->ace > 0)
+	gp = cp->geom;
+	if (cp->acr > 0 || cp->acw > 0 || cp->ace > 0) {
+		w = cp->acw;
 		g_access(cp, -cp->acr, -cp->acw, -cp->ace);
+		if (w > 0 && cp->provider != NULL &&
+		    (cp->provider->geom->flags & G_GEOM_WITHER) == 0) {
+			g_post_event(g_mpd, cp, M_WAITOK, NULL);
+			return;
+		}
+	}
+	sc = gp->softc;
+	mtx_lock(&sc->sc_mtx);
 	if (cp->provider) {
 		printf("GEOM_MULTIPATH: %s removed from %s\n",
-		    cp->provider->name, cp->geom->name);
+		    cp->provider->name, gp->name);
 		g_detach(cp);
 	}
 	g_destroy_consumer(cp);
+	mtx_unlock(&sc->sc_mtx);
+	if (LIST_EMPTY(&gp->consumer))
+		g_multipath_destroy(gp);
 }
 
 static void
 g_multipath_orphan(struct g_consumer *cp)
 {
-	if ((cp->index & MP_POSTED) == 0) {
+	struct g_multipath_softc *sc;
+	uintptr_t *cnt;
+
+	g_topology_assert();
+	printf("GEOM_MULTIPATH: %s in %s was disconnected\n",
+	    cp->provider->name, cp->geom->name);
+	sc = cp->geom->softc;
+	cnt = (uintptr_t *)&cp->private;
+	mtx_lock(&sc->sc_mtx);
+	sc->sc_ndisks--;
+	g_multipath_fault(cp, MP_LOST);
+	if (*cnt == 0 && (cp->index & MP_POSTED) == 0) {
 		cp->index |= MP_POSTED;
-		printf("GEOM_MULTIPATH: %s orphaned in %s\n",
-		    cp->provider->name, cp->geom->name);
+		mtx_unlock(&sc->sc_mtx);
 		g_mpd(cp, 0);
-	}
+	} else
+		mtx_unlock(&sc->sc_mtx);
 }
 
 static void
@@ -126,20 +241,29 @@ g_multipath_start(struct bio *bp)
 	struct g_geom *gp;
 	struct g_consumer *cp;
 	struct bio *cbp;
+	uintptr_t *cnt;
 
 	gp = bp->bio_to->geom;
 	sc = gp->softc;
 	KASSERT(sc != NULL, ("NULL sc"));
-	cp = sc->cp_active;
-	if (cp == NULL) {
-		g_io_deliver(bp, ENXIO);
-		return;
-	}
 	cbp = g_clone_bio(bp);
 	if (cbp == NULL) {
 		g_io_deliver(bp, ENOMEM);
 		return;
 	}
+	mtx_lock(&sc->sc_mtx);
+	cp = g_multipath_choose(gp, bp);
+	if (cp == NULL) {
+		mtx_unlock(&sc->sc_mtx);
+		g_destroy_bio(cbp);
+		g_io_deliver(bp, ENXIO);
+		return;
+	}
+	if ((uintptr_t)bp->bio_driver1 < sc->sc_ndisks)
+		bp->bio_driver1 = (void *)(uintptr_t)sc->sc_ndisks;
+	cnt = (uintptr_t *)&cp->private;
+	(*cnt)++;
+	mtx_unlock(&sc->sc_mtx);
 	cbp->bio_done = g_multipath_done;
 	g_io_request(cbp, cp);
 }
@@ -147,12 +271,27 @@ g_multipath_start(struct bio *bp)
 static void
 g_multipath_done(struct bio *bp)
 {
+	struct g_multipath_softc *sc;
+	struct g_consumer *cp;
+	uintptr_t *cnt;
+
 	if (bp->bio_error == ENXIO || bp->bio_error == EIO) {
 		mtx_lock(&gmtbq_mtx);
 		bioq_insert_tail(&gmtbq, bp);
+		mtx_unlock(&gmtbq_mtx);
 		wakeup(&g_multipath_kt_state);
-		mtx_unlock(&gmtbq_mtx);
 	} else {
+		cp = bp->bio_from;
+		sc = cp->geom->softc;
+		cnt = (uintptr_t *)&cp->private;
+		mtx_lock(&sc->sc_mtx);
+		(*cnt)--;
+		if (*cnt == 0 && (cp->index & MP_LOST)) {
+			cp->index |= MP_POSTED;
+			mtx_unlock(&sc->sc_mtx);
+			g_post_event(g_mpd, cp, M_WAITOK, NULL);
+		} else
+			mtx_unlock(&sc->sc_mtx);
 		g_std_done(bp);
 	}
 }
@@ -165,6 +304,7 @@ g_multipath_done_error(struct bio *bp)
 	struct g_multipath_softc *sc;
 	struct g_consumer *cp;
 	struct g_provider *pp;
+	uintptr_t *cnt;
 
 	/*
 	 * If we had a failure, we have to check first to see
@@ -174,47 +314,33 @@ g_multipath_done_error(struct bio *bp)
 	 * to the next available consumer.
 	 */
 
-	g_topology_lock();
 	pbp = bp->bio_parent;
 	gp = pbp->bio_to->geom;
 	sc = gp->softc;
 	cp = bp->bio_from;
 	pp = cp->provider;
+	cnt = (uintptr_t *)&cp->private;
 
-	cp->index |= MP_BAD;
-	if (cp->nend == cp->nstart && pp->nend == pp->nstart) {
+	mtx_lock(&sc->sc_mtx);
+	if ((cp->index & MP_FAIL) == 0) {
+		printf("GEOM_MULTIPATH: Error %d, %s in %s marked FAIL\n",
+		    bp->bio_error, pp->name, sc->sc_name);
+		g_multipath_fault(cp, MP_FAIL);
+	}
+	(*cnt)--;
+	if (*cnt == 0 && (cp->index & (MP_LOST | MP_POSTED)) == MP_LOST) {
 		cp->index |= MP_POSTED;
-		g_post_event(g_mpd, cp, M_NOWAIT, NULL);
-	}
-	if (cp == sc->cp_active) {
-		struct g_consumer *lcp;
-		printf("GEOM_MULTIPATH: %s failed in %s\n",
-		    pp->name, sc->sc_name);
-		sc->cp_active = NULL;
-		LIST_FOREACH(lcp, &gp->consumer, consumer) {
-			if ((lcp->index & MP_BAD) == 0) {
-				sc->cp_active = lcp;
-				break;
-			}
-		}
-		if (sc->cp_active == NULL) {
-			printf("GEOM_MULTIPATH: out of providers for %s\n",
-			    sc->sc_name);
-			g_topology_unlock();
-			return;
-		} else {
-			printf("GEOM_MULTIPATH: %s now active path in %s\n",
-			    sc->cp_active->provider->name, sc->sc_name);
-		}
-	}
-	g_topology_unlock();
+		mtx_unlock(&sc->sc_mtx);
+		g_post_event(g_mpd, cp, M_WAITOK, NULL);
+	} else
+		mtx_unlock(&sc->sc_mtx);
 
 	/*
 	 * If we can fruitfully restart the I/O, do so.
 	 */
-	if (sc->cp_active) {
+	if (pbp->bio_children < (uintptr_t)pbp->bio_driver1) {
+		pbp->bio_inbed++;
 		g_destroy_bio(bp);
-		pbp->bio_children--;
 		g_multipath_start(pbp);
 	} else {
 		g_std_done(bp);
@@ -238,8 +364,10 @@ g_multipath_kt(void *arg)
 			g_multipath_done_error(bp);
 			mtx_lock(&gmtbq_mtx);
 		}
+		if (g_multipath_kt_state != GKT_RUN)
+			break;
 		msleep(&g_multipath_kt_state, &gmtbq_mtx, PRIBIO,
-		    "gkt:wait", hz / 10);
+		    "gkt:wait", 0);
 	}
 	mtx_unlock(&gmtbq_mtx);
 	wakeup(&g_multipath_kt_state);
@@ -252,6 +380,7 @@ g_multipath_access(struct g_provider *pp, int dr,
 {
 	struct g_geom *gp;
 	struct g_consumer *cp, *badcp = NULL;
+	struct g_multipath_softc *sc;
 	int error;
 
 	gp = pp->geom;
@@ -263,6 +392,10 @@ g_multipath_access(struct g_provider *pp, int dr,
 			goto fail;
 		}
 	}
+	sc = gp->softc;
+	sc->sc_opened += dr + dw + de;
+	if (sc->sc_stopping && sc->sc_opened == 0)
+		g_multipath_destroy(gp);
 	return (0);
 
 fail:
@@ -284,6 +417,9 @@ g_multipath_create(struct g_class *mp, struct g_mu
 	g_topology_assert();
 
 	LIST_FOREACH(gp, &mp->geom, geom) {
+		sc = gp->softc;
+		if (sc == NULL || sc->sc_stopping)
+			continue;
 		if (strcmp(gp->name, md->md_name) == 0) {
 			printf("GEOM_MULTIPATH: name %s already exists\n",
 			    md->md_name);
@@ -292,33 +428,27 @@ g_multipath_create(struct g_class *mp, struct g_mu
 	}
 
 	gp = g_new_geomf(mp, md->md_name);
-	if (gp == NULL)
-		goto fail;
-
 	sc = g_malloc(sizeof(*sc), M_WAITOK | M_ZERO);
+	mtx_init(&sc->sc_mtx, "multipath", NULL, MTX_DEF);
+	memcpy(sc->sc_uuid, md->md_uuid, sizeof (sc->sc_uuid));
+	memcpy(sc->sc_name, md->md_name, sizeof (sc->sc_name));
+	sc->sc_active_active = md->md_active_active;
 	gp->softc = sc;
 	gp->start = g_multipath_start;
 	gp->orphan = g_multipath_orphan;
 	gp->access = g_multipath_access;
-	memcpy(sc->sc_uuid, md->md_uuid, sizeof (sc->sc_uuid));
-	memcpy(sc->sc_name, md->md_name, sizeof (sc->sc_name));
+	gp->dumpconf = g_multipath_dumpconf;
 
 	pp = g_new_providerf(gp, "multipath/%s", md->md_name);
-	if (pp == NULL)
-		goto fail;
-	/* limit the provider to not have it stomp on metadata */
-	pp->mediasize = md->md_size - md->md_sectorsize;
-	pp->sectorsize = md->md_sectorsize;
-	sc->pp = pp;
+	if (md->md_size != 0) {
+		pp->mediasize = md->md_size -
+		    ((md->md_uuid[0] != 0) ? md->md_sectorsize : 0);
+		pp->sectorsize = md->md_sectorsize;
+	}
+	sc->sc_pp = pp;
 	g_error_provider(pp, 0);
+	printf("GEOM_MULTIPATH: %s created\n", gp->name);
 	return (gp);
-fail:
-	if (gp != NULL) {
-		if (gp->softc != NULL)
-			g_free(gp->softc);
-		g_destroy_geom(gp);
-	}
-	return (NULL);
 }
 
 static int
@@ -326,7 +456,7 @@ g_multipath_add_disk(struct g_geom *gp, struct g_p
 {
 	struct g_multipath_softc *sc;
 	struct g_consumer *cp, *nxtcp;
-	int error;
+	int error, acr, acw, ace;
 
 	g_topology_assert();
 
@@ -347,8 +477,8 @@ g_multipath_add_disk(struct g_geom *gp, struct g_p
 	}
 	nxtcp = LIST_FIRST(&gp->consumer);
 	cp = g_new_consumer(gp);
-	if (cp == NULL)
-		return (ENOMEM);
+	cp->private = NULL;
+	cp->index = MP_NEW;
 	error = g_attach(cp, pp);
 	if (error != 0) {
 		printf("GEOM_MULTIPATH: cannot attach %s to %s",
@@ -356,47 +486,93 @@ g_multipath_add_disk(struct g_geom *gp, struct g_p
 		g_destroy_consumer(cp);
 		return (error);
 	}
-	cp->private = sc;
-	cp->index = 0;
 
 	/*
 	 * Set access permissions on new consumer to match other consumers
 	 */
-	if (nxtcp && (nxtcp->acr + nxtcp->acw +  nxtcp->ace)) {
-		error = g_access(cp, nxtcp->acr, nxtcp->acw, nxtcp->ace);
-		if (error) {
-			printf("GEOM_MULTIPATH: cannot set access in "
-			    "attaching %s to %s/%s (%d)\n",
-			    pp->name, sc->sc_name, sc->sc_uuid, error);
-			g_detach(cp);
-			g_destroy_consumer(cp);
-			return (error);
-		}
+	if (sc->sc_pp) {
+		acr = sc->sc_pp->acr;
+		acw = sc->sc_pp->acw;
+		ace = sc->sc_pp->ace;
+	} else
+		acr = acw = ace = 0;
+	if (g_multipath_exclusive) {
+		acr++;
+		acw++;
+		ace++;
 	}
-	printf("GEOM_MULTIPATH: adding %s to %s/%s\n",
-	    pp->name, sc->sc_name, sc->sc_uuid);
-	if (sc->cp_active == NULL) {
-		sc->cp_active = cp;
-		printf("GEOM_MULTIPATH: %s now active path in %s\n",
-		    pp->name, sc->sc_name);
+	error = g_access(cp, acr, acw, ace);
+	if (error) {
+		printf("GEOM_MULTIPATH: cannot set access in "
+		    "attaching %s to %s (%d)\n",
+		    pp->name, sc->sc_name, error);
+		g_detach(cp);
+		g_destroy_consumer(cp);
+		return (error);
 	}
+	if (sc->sc_pp != NULL && sc->sc_pp->mediasize == 0) {
+		sc->sc_pp->mediasize = pp->mediasize -
+		    ((sc->sc_uuid[0] != 0) ? pp->sectorsize : 0);
+		sc->sc_pp->sectorsize = pp->sectorsize;
+	}
+	if (sc->sc_pp != NULL &&
+	    sc->sc_pp->stripesize == 0 && sc->sc_pp->stripeoffset == 0) {
+		sc->sc_pp->stripesize = pp->stripesize;
+		sc->sc_pp->stripeoffset = pp->stripeoffset;
+	}
+	mtx_lock(&sc->sc_mtx);
+	cp->index = 0;
+	sc->sc_ndisks++;
+	mtx_unlock(&sc->sc_mtx);
+	printf("GEOM_MULTIPATH: %s added to %s\n",
+	    pp->name, sc->sc_name);
+	if (sc->sc_active == NULL) {
+		sc->sc_active = cp;
+		if (sc->sc_active_active != 1)
+			printf("GEOM_MULTIPATH: %s is now active path in %s\n",
+			    pp->name, sc->sc_name);
+	}
 	return (0);
 }
 
 static int
 g_multipath_destroy(struct g_geom *gp)
 {
-	struct g_provider *pp;
+	struct g_multipath_softc *sc;
+	struct g_consumer *cp, *cp1;
 
 	g_topology_assert();
 	if (gp->softc == NULL)
 		return (ENXIO);
-	pp = LIST_FIRST(&gp->provider);
-	if (pp != NULL && (pp->acr != 0 || pp->acw != 0 || pp->ace != 0))
-		return (EBUSY);
-	printf("GEOM_MULTIPATH: destroying %s\n", gp->name);
+	sc = gp->softc;
+	if (!sc->sc_stopping) {
+		printf("GEOM_MULTIPATH: destroying %s\n", gp->name);
+		sc->sc_stopping = 1;
+	}
+	if (sc->sc_opened != 0) {
+		if (sc->sc_pp != NULL) {
+			g_wither_provider(sc->sc_pp, ENXIO);
+			sc->sc_pp = NULL;
+		}
+		return (EINPROGRESS);
+	}
+	LIST_FOREACH_SAFE(cp, &gp->consumer, consumer, cp1) {
+		mtx_lock(&sc->sc_mtx);
+		if ((cp->index & MP_POSTED) == 0) {
+			cp->index |= MP_POSTED;
+			mtx_unlock(&sc->sc_mtx);
+			g_mpd(cp, 0);
+			if (cp1 == NULL)
+				return(0);	/* Recursion happened. */
+		} else
+			mtx_unlock(&sc->sc_mtx);
+	}
+	if (!LIST_EMPTY(&gp->consumer))
+		return (EINPROGRESS);
+	mtx_destroy(&sc->sc_mtx);
 	g_free(gp->softc);
 	gp->softc = NULL;
+	printf("GEOM_MULTIPATH: %s destroyed\n", gp->name);
 	g_wither_geom(gp, ENXIO);
 	return (0);
 }
@@ -420,15 +596,15 @@ g_multipath_rotate(struct g_geom *gp)
 		return (ENXIO);
 	LIST_FOREACH(lcp, &gp->consumer, consumer) {
 		if ((lcp->index & MP_BAD) == 0) {
-			if (sc->cp_active != lcp) {
+			if (sc->sc_active != lcp)
 				break;
-			}
 		}
 	}
 	if (lcp) {
-		sc->cp_active = lcp;
-		printf("GEOM_MULTIPATH: %s now active path in %s\n",
-		    lcp->provider->name, sc->sc_name);
+		sc->sc_active = lcp;
+		if (sc->sc_active_active != 1)
+			printf("GEOM_MULTIPATH: %s is now active path in %s\n",
+			    lcp->provider->name, sc->sc_name);
 	}
 	return (0);
 }
@@ -438,8 +614,7 @@ g_multipath_init(struct g_class *mp)
 {
 	bioq_init(&gmtbq);
 	mtx_init(&gmtbq_mtx, "gmtbq", NULL, MTX_DEF);
-	if (kproc_create(g_multipath_kt, mp, NULL, 0, 0, "g_mp_kt") == 0)
-		g_multipath_kt_state = GKT_RUN;
+	kproc_create(g_multipath_kt, mp, NULL, 0, 0, "g_mp_kt");
 }
 
 static void
@@ -516,6 +691,10 @@ g_multipath_taste(struct g_class *mp, struct g_pro
 		    G_MULTIPATH_VERSION);
 		return (NULL);
 	}
+	if (md.md_size != 0 && md.md_size != pp->mediasize)
+		return (NULL);
+	if (md.md_sectorsize != 0 && md.md_sectorsize != pp->sectorsize)
+		return (NULL);
 	if (g_multipath_debug)
 		printf("MULTIPATH: %s/%s\n", md.md_name, md.md_uuid);
 
@@ -533,7 +712,7 @@ g_multipath_taste(struct g_class *mp, struct g_pro
 	sc = NULL;
 	LIST_FOREACH(gp, &mp->geom, geom) {
 		sc = gp->softc;
-		if (sc == NULL)
+		if (sc == NULL || sc->sc_stopping)
 			continue;
 		if (strncmp(md.md_uuid, sc->sc_uuid, sizeof(md.md_uuid)) == 0)
 			break;
@@ -543,7 +722,7 @@ g_multipath_taste(struct g_class *mp, struct g_pro
 		if (gp1 == gp)
 			continue;
 		sc = gp1->softc;
-		if (sc == NULL)
+		if (sc == NULL || sc->sc_stopping)
 			continue;
 		if (strncmp(md.md_name, sc->sc_name, sizeof(md.md_name)) == 0)
 			break;
@@ -603,12 +782,14 @@ g_multipath_taste(struct g_class *mp, struct g_pro
 }
 
 static void
-g_multipath_ctl_add(struct gctl_req *req, struct g_class *mp)
+g_multipath_ctl_add_name(struct gctl_req *req, struct g_class *mp,
+    const char *name)
 {
+	struct g_multipath_softc *sc;
 	struct g_geom *gp;
 	struct g_consumer *cp;
-	struct g_provider *pp, *pp0;
-	const char *name, *mpname;
+	struct g_provider *pp;
+	const char *mpname;
 	static const char devpf[6] = "/dev/";
 
 	g_topology_assert();
@@ -623,12 +804,8 @@ static void
 		gctl_error(req, "Device %s is invalid", mpname);
 		return;
 	}
+	sc = gp->softc;
 
-	name = gctl_get_asciiparam(req, "arg1");
-	if (name == NULL) {
-		gctl_error(req, "No 'arg1' argument");
-		return;
-	}
 	if (strncmp(name, devpf, 5) == 0)
 		name += 5;
 	pp = g_provider_by_name(name);
@@ -638,33 +815,30 @@ static void
 	}
 
 	/*
-	 * Check to make sure parameters match, if we already have one.
+	 * Check to make sure parameters match.
 	 */
-	cp = LIST_FIRST(&gp->consumer);
-	if (cp) {
-		pp0 = cp->provider;
-	} else {
-		pp0 = NULL;
-	}
-	if (pp0) {
-		if (pp0 == pp) {
-			gctl_error(req, "providers %s and %s are the same",
-			    pp0->name, pp->name);
+	LIST_FOREACH(cp, &gp->consumer, consumer) {
+		if (cp->provider == pp) {
+			gctl_error(req, "provider %s is already there",
+			    pp->name);
 			return;
 		}
-		if (pp0->mediasize != pp->mediasize) {
-			gctl_error(req, "Provider %s is %jd; Provider %s is %jd",
-			    pp0->name, (intmax_t) pp0->mediasize,
-			    pp->name, (intmax_t) pp->mediasize);
-			return;
-		}
-		if (pp0->sectorsize != pp->sectorsize) {
-			gctl_error(req, "Provider %s has sectorsize %u; Provider %s "
-			    "has sectorsize %u", pp0->name, pp0->sectorsize,
-			    pp->name, pp->sectorsize);
-			return;
-		}
 	}
+	if (sc->sc_pp != NULL && sc->sc_pp->mediasize != 0 &&
+	    sc->sc_pp->mediasize + (sc->sc_uuid[0] != 0 ? pp->sectorsize : 0)
+	     != pp->mediasize) {
+		gctl_error(req, "Providers size mismatch %jd != %jd",
+		    (intmax_t) sc->sc_pp->mediasize +
+			(sc->sc_uuid[0] != 0 ? pp->sectorsize : 0),
+		    (intmax_t) pp->mediasize);
+		return;
+	}
+	if (sc->sc_pp != NULL && sc->sc_pp->sectorsize != 0 &&
+	    sc->sc_pp->sectorsize != pp->sectorsize) {
+		gctl_error(req, "Providers sectorsize mismatch %u != %u",
+		    sc->sc_pp->sectorsize, pp->sectorsize);
+		return;
+	}
 
 	/*
 	 * Now add....
@@ -672,24 +846,311 @@ static void
 	(void) g_multipath_add_disk(gp, pp);
 }
 
+static void
+g_multipath_ctl_add(struct gctl_req *req, struct g_class *mp)
+{
+	struct g_multipath_softc *sc;
+	struct g_geom *gp;
+	const char *mpname, *name;
+
+	mpname = gctl_get_asciiparam(req, "arg0");
+        if (mpname == NULL) {
+                gctl_error(req, "No 'arg0' argument");
+                return;
+        }
+	gp = g_multipath_find_geom(mp, mpname);
+	if (gp == NULL) {
+		gctl_error(req, "Device %s not found", mpname);
+		return;
+	}
+	sc = gp->softc;
+
+	name = gctl_get_asciiparam(req, "arg1");
+	if (name == NULL) {
+		gctl_error(req, "No 'arg1' argument");
+		return;
+	}
+	g_multipath_ctl_add_name(req, mp, name);
+}
+
+static void
+g_multipath_ctl_create(struct gctl_req *req, struct g_class *mp)
+{
+	struct g_multipath_metadata md;
+	struct g_multipath_softc *sc;
+	struct g_geom *gp;
+	const char *mpname, *name;
+	char param[16];
+	int *nargs, i, *val;
+
+	g_topology_assert();
+
+	nargs = gctl_get_paraml(req, "nargs", sizeof(*nargs));
+	if (*nargs < 2) {
+		gctl_error(req, "wrong number of arguments.");
+		return;
+	}
+
+	mpname = gctl_get_asciiparam(req, "arg0");
+        if (mpname == NULL) {
+                gctl_error(req, "No 'arg0' argument");
+                return;
+        }
+	gp = g_multipath_find_geom(mp, mpname);
+	if (gp != NULL) {
+		gctl_error(req, "Device %s already exist", mpname);
+		return;
+	}
+	sc = gp->softc;
+
+	memset(&md, 0, sizeof(md));
+	strlcpy(md.md_magic, G_MULTIPATH_MAGIC, sizeof(md.md_magic));
+	md.md_version = G_MULTIPATH_VERSION;
+	strlcpy(md.md_name, mpname, sizeof(md.md_name));
+	md.md_size = 0;
+	md.md_sectorsize = 0;
+	md.md_uuid[0] = 0;
+	md.md_active_active = 0;
+	val = gctl_get_paraml(req, "active_active", sizeof(*val));
+	if (val != NULL && *val != 0)
+		md.md_active_active = 1;
+	val = gctl_get_paraml(req, "active_read", sizeof(*val));
+	if (val != NULL && *val != 0)
+		md.md_active_active = 2;
+	gp = g_multipath_create(mp, &md);
+	if (gp == NULL) {
+		gctl_error(req, "GEOM_MULTIPATH: cannot create geom %s/%s\n",
+		    md.md_name, md.md_uuid);
+		return;
+	}
+	sc = gp->softc;
+
+	for (i = 1; i < *nargs; i++) {
+		snprintf(param, sizeof(param), "arg%d", i);
+		name = gctl_get_asciiparam(req, param);
+		g_multipath_ctl_add_name(req, mp, name);
+	}
+
+	if (sc->sc_ndisks != (*nargs - 1))
+		g_multipath_destroy(gp);
+}
+
+static void
+g_multipath_ctl_configure(struct gctl_req *req, struct g_class *mp)
+{
+	struct g_multipath_softc *sc;
+	struct g_geom *gp;
+	struct g_consumer *cp;
+	struct g_provider *pp;
+	struct g_multipath_metadata md;
+	const char *name;
+	int error, *val;
+	void *buf;
+
+	g_topology_assert();
+
+	name = gctl_get_asciiparam(req, "arg0");
+	if (name == NULL) {
+		gctl_error(req, "No 'arg0' argument");
+		return;
+	}
+	gp = g_multipath_find_geom(mp, name);
+	if (gp == NULL) {
+		gctl_error(req, "Device %s is invalid", name);
+		return;
+	}
+	sc = gp->softc;
+	val = gctl_get_paraml(req, "active_active", sizeof(*val));
+	if (val != NULL && *val != 0)
+		sc->sc_active_active = 1;
+	val = gctl_get_paraml(req, "active_read", sizeof(*val));
+	if (val != NULL && *val != 0)
+		sc->sc_active_active = 2;
+	val = gctl_get_paraml(req, "active_passive", sizeof(*val));
+	if (val != NULL && *val != 0)
+		sc->sc_active_active = 0;
+	if (sc->sc_uuid[0] != 0 && sc->sc_active != NULL) {
+		cp = sc->sc_active;
+		pp = cp->provider;
+		error = g_access(cp, 1, 1, 1);
+		if (error != 0) {
+			gctl_error(req, "Can't open %s (%d)", pp->name, error);
+			return;
+		}
+		g_topology_unlock();
+		buf = g_malloc(pp->sectorsize, M_WAITOK | M_ZERO);
+		strlcpy(md.md_magic, G_MULTIPATH_MAGIC, sizeof(md.md_magic));
+		memcpy(md.md_uuid, sc->sc_uuid, sizeof (sc->sc_uuid));
+		strlcpy(md.md_name, name, sizeof(md.md_name));
+		md.md_version = G_MULTIPATH_VERSION;
+		md.md_size = pp->mediasize;
+		md.md_sectorsize = pp->sectorsize;
+		md.md_active_active = sc->sc_active_active;
+		multipath_metadata_encode(&md, buf);
+		error = g_write_data(cp, pp->mediasize - pp->sectorsize,
+		    buf, pp->sectorsize);
+		g_topology_lock();
+		g_access(cp, -1, -1, -1);
+		if (error != 0)
+			gctl_error(req, "Can't update metadata on %s (%d)",
+			    pp->name, error);
+	}
+}
+
+static void
+g_multipath_ctl_fail(struct gctl_req *req, struct g_class *mp, int fail)
+{
+	struct g_multipath_softc *sc;
+	struct g_geom *gp;
+	struct g_consumer *cp;
+	const char *mpname, *name;
+	int found;
+
+	mpname = gctl_get_asciiparam(req, "arg0");
+        if (mpname == NULL) {
+                gctl_error(req, "No 'arg0' argument");
+                return;
+        }
+	gp = g_multipath_find_geom(mp, mpname);
+	if (gp == NULL) {
+		gctl_error(req, "Device %s not found", mpname);
+		return;
+	}
+	sc = gp->softc;
+
+	name = gctl_get_asciiparam(req, "arg1");
+	if (name == NULL) {
+		gctl_error(req, "No 'arg1' argument");
+		return;
+	}
+
+	found = 0;
+	mtx_lock(&sc->sc_mtx);
+	LIST_FOREACH(cp, &gp->consumer, consumer) {
+		if (cp->provider != NULL &&
+		    strcmp(cp->provider->name, name) == 0 &&
+		    (cp->index & MP_LOST) == 0) {
+			found = 1;
+			if (!fail == !(cp->index & MP_FAIL))
+				continue;
+			printf("GEOM_MULTIPATH: %s in %s is marked %s.\n",
+				name, sc->sc_name, fail ? "FAIL" : "OK");
+			if (fail) {
+				g_multipath_fault(cp, MP_FAIL);
+			} else {
+				cp->index &= ~MP_FAIL;
+			}
+		}
+	}
+	mtx_unlock(&sc->sc_mtx);
+	if (found == 0)
+		gctl_error(req, "Provider %s not found", name);
+}
+
+static void
+g_multipath_ctl_remove(struct gctl_req *req, struct g_class *mp)
+{
+	struct g_multipath_softc *sc;
+	struct g_geom *gp;
+	struct g_consumer *cp, *cp1;
+	const char *mpname, *name;
+	uintptr_t *cnt;
+	int found;
+
+	mpname = gctl_get_asciiparam(req, "arg0");
+        if (mpname == NULL) {
+                gctl_error(req, "No 'arg0' argument");
+                return;
+        }
+	gp = g_multipath_find_geom(mp, mpname);
+	if (gp == NULL) {
+		gctl_error(req, "Device %s not found", mpname);
+		return;
+	}
+	sc = gp->softc;
+
+	name = gctl_get_asciiparam(req, "arg1");
+	if (name == NULL) {
+		gctl_error(req, "No 'arg1' argument");
+		return;
+	}
+
+	found = 0;
+	mtx_lock(&sc->sc_mtx);
+	LIST_FOREACH_SAFE(cp, &gp->consumer, consumer, cp1) {
+		if (cp->provider != NULL &&
+		    strcmp(cp->provider->name, name) == 0 &&
+		    (cp->index & MP_LOST) == 0) {
+			found = 1;
+			printf("GEOM_MULTIPATH: removing %s from %s\n",
+			    cp->provider->name, cp->geom->name);
+			sc->sc_ndisks--;
+			g_multipath_fault(cp, MP_LOST);
+			cnt = (uintptr_t *)&cp->private;
+			if (*cnt == 0 && (cp->index & MP_POSTED) == 0) {
+				cp->index |= MP_POSTED;
+				mtx_unlock(&sc->sc_mtx);
+				g_mpd(cp, 0);
+				if (cp1 == NULL)
+					return;	/* Recursion happened. */
+				mtx_lock(&sc->sc_mtx);
+			}
+		}
+	}
+	mtx_unlock(&sc->sc_mtx);
+	if (found == 0)
+		gctl_error(req, "Provider %s not found", name);
+}
+
 static struct g_geom *
 g_multipath_find_geom(struct g_class *mp, const char *name)
 {
 	struct g_geom *gp;
+	struct g_multipath_softc *sc;
 
 	LIST_FOREACH(gp, &mp->geom, geom) {
-		if (strcmp(gp->name, name) == 0) {
+		sc = gp->softc;
+		if (sc == NULL || sc->sc_stopping)
+			continue;
+		if (strcmp(gp->name, name) == 0)
 			return (gp);
-		}
 	}
 	return (NULL);
 }
 
 static void
+g_multipath_ctl_stop(struct gctl_req *req, struct g_class *mp)
+{
+	struct g_geom *gp;
+	const char *name;
+	int error;
+
+	g_topology_assert();
+
+	name = gctl_get_asciiparam(req, "arg0");
+        if (name == NULL) {
+                gctl_error(req, "No 'arg0' argument");
+                return;
+        }
+	gp = g_multipath_find_geom(mp, name);
+	if (gp == NULL) {
+		gctl_error(req, "Device %s is invalid", name);
+		return;
+	}
+	error = g_multipath_destroy(gp);
+	if (error != 0 && error != EINPROGRESS)
+		gctl_error(req, "failed to stop %s (err=%d)", name, error);
+}
+
+static void
 g_multipath_ctl_destroy(struct gctl_req *req, struct g_class *mp)
 {
 	struct g_geom *gp;
+	struct g_multipath_softc *sc;
+	struct g_consumer *cp;
+	struct g_provider *pp;
 	const char *name;
+	uint8_t *buf;
 	int error;
 
 	g_topology_assert();
@@ -704,10 +1165,31 @@ g_multipath_ctl_destroy(struct gctl_req *req, stru
 		gctl_error(req, "Device %s is invalid", name);
 		return;
 	}
+	sc = gp->softc;
+
+	if (sc->sc_uuid[0] != 0 && sc->sc_active != NULL) {
+		cp = sc->sc_active;
+		pp = cp->provider;
+		error = g_access(cp, 1, 1, 1);
+		if (error != 0) {
+			gctl_error(req, "Can't open %s (%d)", pp->name, error);
+			goto destroy;
+		}
+		g_topology_unlock();
+		buf = g_malloc(pp->sectorsize, M_WAITOK | M_ZERO);
+		error = g_write_data(cp, pp->mediasize - pp->sectorsize,
+		    buf, pp->sectorsize);
+		g_topology_lock();
+		g_access(cp, -1, -1, -1);
+		if (error != 0)
+			gctl_error(req, "Can't erase metadata on %s (%d)",
+			    pp->name, error);
+	}
+
+destroy:
 	error = g_multipath_destroy(gp);
-	if (error != 0) {
+	if (error != 0 && error != EINPROGRESS)
 		gctl_error(req, "failed to destroy %s (err=%d)", name, error);
-	}
 }
 
 static void
@@ -741,7 +1223,9 @@ g_multipath_ctl_getactive(struct gctl_req *req, st
 	struct sbuf *sb;
 	struct g_geom *gp;
 	struct g_multipath_softc *sc;
+	struct g_consumer *cp;
 	const char *name;
+	int empty;
 
 	sb = sbuf_new_auto();
 
@@ -757,8 +1241,21 @@ g_multipath_ctl_getactive(struct gctl_req *req, st
 		return;
 	}
 	sc = gp->softc;
-	if (sc->cp_active) {
-		sbuf_printf(sb, "%s\n", sc->cp_active->provider->name);
+	if (sc->sc_active_active == 1) {
+		empty = 1;
+		LIST_FOREACH(cp, &gp->consumer, consumer) {
+			if (cp->index & MP_BAD)
+				continue;
+			if (!empty)
+				sbuf_cat(sb, " ");
+			sbuf_cat(sb, cp->provider->name);
+			empty = 0;
+		}
+		if (empty)
+			sbuf_cat(sb, "none");
+		sbuf_cat(sb, "\n");
+	} else if (sc->sc_active && sc->sc_active->provider) {
+		sbuf_printf(sb, "%s\n", sc->sc_active->provider->name);
 	} else {
 		sbuf_printf(sb, "none\n");
 	}
@@ -779,8 +1276,20 @@ g_multipath_config(struct gctl_req *req, struct g_
 		gctl_error(req, "Userland and kernel parts are out of sync");
 	} else if (strcmp(verb, "add") == 0) {
 		g_multipath_ctl_add(req, mp);
+	} else if (strcmp(verb, "create") == 0) {
+		g_multipath_ctl_create(req, mp);
+	} else if (strcmp(verb, "configure") == 0) {
+		g_multipath_ctl_configure(req, mp);
+	} else if (strcmp(verb, "stop") == 0) {
+		g_multipath_ctl_stop(req, mp);
 	} else if (strcmp(verb, "destroy") == 0) {
 		g_multipath_ctl_destroy(req, mp);
+	} else if (strcmp(verb, "fail") == 0) {
+		g_multipath_ctl_fail(req, mp, 1);
+	} else if (strcmp(verb, "restore") == 0) {
+		g_multipath_ctl_fail(req, mp, 0);
+	} else if (strcmp(verb, "remove") == 0) {
+		g_multipath_ctl_remove(req, mp);
 	} else if (strcmp(verb, "rotate") == 0) {
 		g_multipath_ctl_rotate(req, mp);
 	} else if (strcmp(verb, "getactive") == 0) {
@@ -789,4 +1298,42 @@ g_multipath_config(struct gctl_req *req, struct g_
 		gctl_error(req, "Unknown verb %s", verb);
 	}
 }
+
+static void
+g_multipath_dumpconf(struct sbuf *sb, const char *indent, struct g_geom *gp,
+    struct g_consumer *cp, struct g_provider *pp)
+{
+	struct g_multipath_softc *sc;
+	int good;
+
+	g_topology_assert();
+
+	sc = gp->softc;
+	if (sc == NULL)
+		return;
+	if (cp != NULL) {
+		sbuf_printf(sb, "%s<State>%s</State>", indent,
+		    (cp->index & MP_NEW) ? "NEW" :
+		    (cp->index & MP_LOST) ? "LOST" :
+		    (cp->index & MP_FAIL) ? "FAIL" :
+		    (sc->sc_active_active == 1 || sc->sc_active == cp) ?
+		     "ACTIVE" :
+		     sc->sc_active_active == 2 ? "READ" : "PASSIVE");
+	} else {
+		good = g_multipath_good(gp);
+		sbuf_printf(sb, "%s<State>%s</State>", indent,
+		    good == 0 ? "BROKEN" :
+		    (good != sc->sc_ndisks || sc->sc_ndisks == 1) ?
+		    "DEGRADED" : "OPTIMAL");
+	}
+	if (cp == NULL && pp == NULL) {
+		sbuf_printf(sb, "%s<UUID>%s</UUID>", indent, sc->sc_uuid);
+		sbuf_printf(sb, "%s<Mode>Active/%s</Mode>", indent,
+		    sc->sc_active_active == 2 ? "Read" :
+		    sc->sc_active_active == 1 ? "Active" : "Passive");
+		sbuf_printf(sb, "%s<Type>%s</Type>", indent,
+		    sc->sc_uuid[0] == 0 ? "MANUAL" : "AUTOMATIC");
+	}
+}
+
 DECLARE_GEOM_CLASS(g_multipath_class, g_multipath);
