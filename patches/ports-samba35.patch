Index: net/samba35/Makefile
===================================================================
RCS file: /home/ncvs/ports/net/samba35/Makefile,v
retrieving revision 1.7
diff -u -p -r1.7 Makefile
--- net/samba35/Makefile	20 Jun 2011 02:56:29 -0000	1.7
+++ net/samba35/Makefile	9 Aug 2011 19:30:02 -0000
@@ -2,11 +2,11 @@
 # Date created:				1 May 2010
 # Whom:					timur@FreeBSD.org
 #
-# $FreeBSD: ports/net/samba35/Makefile,v 1.7 2011/06/20 02:56:29 timur Exp $
+# $FreeBSD: ports/net/samba35/Makefile,v 1.8 2011/08/09 01:59:58 timur Exp $
 #
 
 PORTNAME=		${SAMBA_BASENAME}35
-PORTVERSION=		3.5.9
+PORTVERSION=		3.5.11
 PORTREVISION?=		0
 CATEGORIES?=		net
 MASTER_SITES=		${MASTER_SITE_SAMBA}
@@ -16,7 +16,7 @@ DISTNAME=		${SAMBA_BASENAME}-${PORTVERSI
 MAINTAINER?=		timur@FreeBSD.org
 COMMENT?=		A free SMB and CIFS client and server for UNIX
 
-CONFLICTS?=		*samba3[2-4]-3.*
+CONFLICTS?=		*samba3[2-46]-3.*
 # Additional patches from Sernet.de
 PATCH_STRIP=		-p1
 EXTRA_PATCHES=		${PATCHDIR}/sernet.patch
@@ -77,7 +77,7 @@ LDFLAGS+=		-L${LOCALBASE}/lib
 CONFIGURE_ENV+=		LDFLAGS="${LDFLAGS}" \
 			PTHREAD_CFLAGS="${PTHREAD_CFLAGS}" \
 			PTHREAD_LDFLAGS="${PTHREAD_LIBS}"
-# pkg-config is used to find talloc
+# pkg-config is used to find talloc, tevent and tdb
 PKGCONFIGDIR?=		${PREFIX}/libdata/pkgconfig
 PKGCONFIGDIR_REL?=	${PKGCONFIGDIR:S|^${PREFIX}/||}
 
@@ -94,6 +94,10 @@ CONFIGURE_ARGS+=	--without-libtdb --enab
 BUILD_DEPENDS+=		talloc>=2.0.1:${PORTSDIR}/devel/talloc
 RUN_DEPENDS+=		talloc>=2.0.1:${PORTSDIR}/devel/talloc
 CONFIGURE_ARGS+=	--without-libtalloc --enable-external-libtalloc
+# tevent
+#BUILD_DEPENDS+=	tevent>=0.9.13:${PORTSDIR}/devel/tevent
+#RUN_DEPENDS+=		tevent>=0.9.13:${PORTSDIR}/devel/tevent
+#CONFIGURE_ARGS+=	--without-libtevent --enable-external-libtevent
 # These options are common for all (sub)ports
 CONFIGURE_ARGS+=	--with-libiconv="${LOCALBASE}"
 
@@ -238,7 +242,8 @@ WANT_EXP_MODULES=	idmap_tdb2 idmap_ad id
 WANT_EXP_MODULES+=	rpc_echo
 .		endif
 WANT_EXP_MODULES+=	vfs_cacheprime vfs_catia vfs_commit vfs_dirsort \
-			vfs_readahead vfs_streams_depot vfs_syncops
+			vfs_readahead vfs_streams_depot vfs_syncops \
+			vfs_crossrename
 .	endif
 .endif
 
Index: net/samba35/distinfo
===================================================================
RCS file: /home/ncvs/ports/net/samba35/distinfo,v
retrieving revision 1.3
diff -u -p -r1.3 distinfo
--- net/samba35/distinfo	20 Jun 2011 02:56:29 -0000	1.3
+++ net/samba35/distinfo	9 Aug 2011 19:30:02 -0000
@@ -1,2 +1,2 @@
-SHA256 (samba-3.5.9.tar.gz) = 8af8dccbb87a70a71f795180d873102b5cccba7012d66f2620cea8b87174380a
-SIZE (samba-3.5.9.tar.gz) = 30750297
+SHA256 (samba-3.5.11.tar.gz) = fba5b7bced99a0651148d74f40031ac3ca3fc7869e2998bc85bf6fb3ddb16597
+SIZE (samba-3.5.11.tar.gz) = 30752782
Index: net/samba35/files/patch-lib__replace__system__config.m4
===================================================================
RCS file: /home/ncvs/ports/net/samba35/files/patch-lib__replace__system__config.m4,v
retrieving revision 1.1
diff -u -p -r1.1 patch-lib__replace__system__config.m4
--- net/samba35/files/patch-lib__replace__system__config.m4	26 Oct 2010 02:41:58 -0000	1.1
+++ net/samba35/files/patch-lib__replace__system__config.m4	9 Aug 2011 19:30:02 -0000
@@ -4,8 +4,8 @@
  # filesys
  AC_HEADER_DIRENT 
  AC_CHECK_HEADERS(fcntl.h sys/fcntl.h sys/resource.h sys/ioctl.h sys/mode.h sys/filio.h sys/fs/s5param.h sys/filsys.h)
--AC_CHECK_HEADERS(sys/acl.h acl/libacl.h)
-+AC_CHECK_HEADERS(sys/acl.h acl/libacl.h sunacl.h)
+-AC_CHECK_HEADERS(sys/acl.h acl/libacl.h sys/file.h)
++AC_CHECK_HEADERS(sys/acl.h acl/libacl.h sunacl.h sys/file.h)
  
  # select
  AC_CHECK_HEADERS(sys/select.h)
Index: net/samba35/files/patch-source3__modules__vfs_shadow_copy2.c
===================================================================
RCS file: net/samba35/files/patch-source3__modules__vfs_shadow_copy2.c
diff -N net/samba35/files/patch-source3__modules__vfs_shadow_copy2.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ net/samba35/files/patch-source3__modules__vfs_shadow_copy2.c	9 Aug 2011 19:30:25 -0000
@@ -0,0 +1,308 @@
+--- ./source3/modules/vfs_shadow_copy2.c.orig	2011-06-14 04:17:28.000000000 -0700
++++ ./source3/modules/vfs_shadow_copy2.c	2011-07-01 21:44:13.133596276 -0700
+@@ -2,6 +2,7 @@
+  * implementation of an Shadow Copy module - version 2
+  *
+  * Copyright (C) Andrew Tridgell     2007
++ * Copyright (C) Ed Plese            2009
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+@@ -34,6 +35,16 @@
+      from the original. This allows the 'restore' button to work
+      without a sharing violation
+ 
++     3) vanity naming for snapshots. Snapshots can be named in any
++     format compatible with str[fp]time conversions.
++
++     4) time stamps in snapshot names can be represented in localtime
++     rather than UTC.
++
++     5) shadow copy results can be sorted before being sent to the
++     client.  This is beneficial for filesystems that don't read
++     directories alphabetically (e.g. ZFS).
++
+   Module options:
+ 
+       shadow:snapdir = <directory where snapshots are kept>
+@@ -58,10 +69,29 @@
+       don't set this option then the 'restore' button in the shadow
+       copy UI will fail with a sharing violation.
+ 
+-  Note that the directory names in the snapshot directory must take the form
+-  @GMT-YYYY.MM.DD-HH.MM.SS
+-  
+-  The following command would generate a correctly formatted directory name:
++      shadow:sort = asc/desc, or blank for unsorted (default)
++
++      This is an optional parameter that specifies that the shadow
++      copy directories should be sorted before sending them to the
++      client.  This is beneficial for filesystems that don't read
++      directories alphabetically (e.g. ZFS).  If enabled, you typically
++      want to specify descending order.
++
++      shadow:format = <format specification for snapshot names>
++
++      This is an optional parameter that specifies the format
++      specification for the naming of snapshots.  The format must
++      be compatible with the conversion specifications recognized
++      by str[fp]time.  The default value is "@GMT-%Y.%m.%d-%H.%M.%S".
++
++      shadow:localtime = yes/no (default is no)
++
++      This is an optional parameter that indicates whether the
++      snapshot names are in UTC/GMT or the local time.
++      
++
++  The following command would generate a correctly formatted directory name
++  for use with the default parameters:
+      date -u +@GMT-%Y.%m.%d-%H.%M.%S
+   
+  */
+@@ -72,6 +102,11 @@
+ #define DBGC_CLASS vfs_shadow_copy2_debug_level
+ 
+ #define GMT_NAME_LEN 24 /* length of a @GMT- name */
++#define SHADOW_COPY2_GMT_FORMAT "@GMT-%Y.%m.%d-%H.%M.%S"
++
++#define SHADOW_COPY2_DEFAULT_SORT ""
++#define SHADOW_COPY2_DEFAULT_LOCALTIME (False)
++#define SHADOW_COPY2_DEFAULT_FORMAT "@GMT-%Y.%m.%d-%H.%M.%S"
+ 
+ /*
+   make very sure it is one of our special names 
+@@ -158,6 +193,40 @@
+ 	return pcopy;
+ }
+ 
++static char *shadow_copy2_snapshot_to_gmt(TALLOC_CTX *mem_ctx, vfs_handle_struct *handle, const char *name)
++{
++	struct tm timestamp;
++	time_t timestamp_t;
++	char gmt[GMT_NAME_LEN + 1];
++
++	char *fmt = talloc_strdup(mem_ctx,
++		lp_parm_const_string(SNUM(handle->conn),
++			"shadow", "format", SHADOW_COPY2_DEFAULT_FORMAT));
++
++	if (fmt == NULL) {
++		DEBUG(0, ("shadow_copy2_snapshot_to_gmt: talloc_strdup failed for format\n"));
++		return NULL;
++	}
++
++	memset(&timestamp, 0, sizeof(timestamp));
++	if (strptime(name, fmt, &timestamp) == NULL) {
++		DEBUG(10, ("shadow_copy2_snapshot_to_gmt: no match %s: %s\n", fmt, name));
++		talloc_free(fmt);
++		return NULL;
++	}
++
++	DEBUG(10, ("shadow_copy2_snapshot_to_gmt: match %s: %s\n", fmt, name));
++	if (lp_parm_bool(SNUM(handle->conn), "shadow", "localtime", SHADOW_COPY2_DEFAULT_LOCALTIME)) {
++		timestamp.tm_isdst = -1;
++		timestamp_t = mktime(&timestamp);
++		gmtime_r(&timestamp_t, &timestamp);
++	}
++	strftime(gmt, sizeof(gmt), SHADOW_COPY2_GMT_FORMAT, &timestamp);
++	talloc_free(fmt);
++
++	return talloc_strdup(mem_ctx, gmt);
++}
++
+ /*
+   convert a name to the shadow directory
+  */
+@@ -347,6 +416,19 @@
+ 	size_t baselen;
+ 	char *ret;
+ 
++	struct tm timestamp;
++	time_t timestamp_t;
++	char snapshot[MAXPATHLEN];
++	char *fmt = talloc_strdup(tmp_ctx,
++		lp_parm_const_string(SNUM(handle->conn),
++			"shadow", "format", SHADOW_COPY2_DEFAULT_FORMAT));
++
++	if (fmt == NULL) {
++		DEBUG(0, ("shadow_copy2_convert: talloc_strdup failed for format\n"));
++		talloc_free(tmp_ctx);
++		return NULL;
++	}
++
+ 	snapdir = shadow_copy2_find_snapdir(tmp_ctx, handle);
+ 	if (snapdir == NULL) {
+ 		DEBUG(2,("no snapdir found for share at %s\n", handle->conn->connectpath));
+@@ -369,7 +451,22 @@
+ 		}
+ 	}
+ 
+-	relpath = fname + GMT_NAME_LEN;
++	memset(&timestamp, 0, sizeof(timestamp));
++	relpath = strptime(fname, SHADOW_COPY2_GMT_FORMAT, &timestamp);
++	if (relpath == NULL) {
++		talloc_free(tmp_ctx);
++		return NULL;
++	}
++
++	/* relpath is the remaining portion of the path after the @GMT-xxx */
++
++	if (lp_parm_bool(SNUM(handle->conn), "shadow", "localtime", SHADOW_COPY2_DEFAULT_LOCALTIME)) {
++		timestamp_t = timegm(&timestamp);
++		localtime_r(&timestamp_t, &timestamp);
++	}
++
++	strftime(snapshot, MAXPATHLEN, fmt, &timestamp);
++
+ 	baselen = strlen(basedir);
+ 	baseoffset = handle->conn->connectpath + baselen;
+ 
+@@ -385,11 +482,15 @@
+ 	if (*relpath == '/') relpath++;
+ 	if (*baseoffset == '/') baseoffset++;
+ 
+-	ret = talloc_asprintf(handle->data, "%s/%.*s/%s/%s", 
++	ret = talloc_asprintf(handle->data, "%s/%s%s%s/%s", 
+ 			      snapdir, 
+-			      GMT_NAME_LEN, fname, 
++			      snapshot,
++			      *baseoffset ? "/" : "",
+ 			      baseoffset, 
+ 			      relpath);
++	/* XXX */
++	if (ret != NULL && strlen(ret) > 1 && ret[strlen(ret) - 1] == '/')
++		ret[strlen(ret) - 1] = '\0';
+ 	DEBUG(6,("convert_shadow2_name: '%s' -> '%s'\n", fname, ret));
+ 	talloc_free(tmp_ctx);
+ 	return ret;
+@@ -557,6 +658,7 @@
+ static char *shadow_copy2_realpath(vfs_handle_struct *handle,
+ 			    const char *fname, char *resolved_path)
+ {
++#if 0
+ 	const char *gmt;
+ 
+ 	if (shadow_copy2_match_name(fname, &gmt)
+@@ -576,6 +678,7 @@
+ 		TALLOC_FREE(copy);
+ 		return result;
+ 	}
++#endif
+         SHADOW2_NEXT(REALPATH, (handle, name, resolved_path), char *, NULL);
+ }
+ 
+@@ -606,6 +709,7 @@
+ 		return NULL;
+ 	}
+ 
++#if 0
+ 	snapdir = shadow_copy2_find_snapdir(tmp_ctx, handle);
+ 	if (snapdir == NULL) {
+ 		DEBUG(2,("no snapdir found for share at %s\n",
+@@ -642,6 +746,9 @@
+ 			      snapdir,
+ 			      GMT_NAME_LEN, fname,
+ 			      baseoffset);
++#else
++	ret = convert_shadow2_name(handle, fname, gmt_start);
++#endif
+ 	DEBUG(6,("shadow_copy2_connectpath: '%s' -> '%s'\n", fname, ret));
+ 	TALLOC_FREE(tmp_ctx);
+ 	return ret;
+@@ -718,6 +825,45 @@
+         SHADOW2_NEXT(CHMOD_ACL, (handle, name, mode), int, -1);
+ }
+ 
++static int shadow_copy2_label_cmp_asc(const void *x, const void *y)
++{
++	return strncmp((char *)x, (char *)y, sizeof(SHADOW_COPY_LABEL));
++}
++
++static int shadow_copy2_label_cmp_desc(const void *x, const void *y)
++{
++	return -strncmp((char *)x, (char *)y, sizeof(SHADOW_COPY_LABEL));
++}
++
++/*
++  sort the shadow copy data in ascending or descending order
++ */
++static void shadow_copy2_sort_data(vfs_handle_struct *handle,
++				   SHADOW_COPY_DATA *shadow_copy2_data)
++{
++	const char *tmp_str = lp_parm_const_string(SNUM(handle->conn),
++		"shadow", "sort", SHADOW_COPY2_DEFAULT_SORT);
++
++	if (tmp_str && shadow_copy2_data &&
++		shadow_copy2_data->num_volumes > 0 &&
++		shadow_copy2_data->labels) {
++
++		if (strcmp(tmp_str, "asc") == 0) {
++			qsort(shadow_copy2_data->labels,
++				shadow_copy2_data->num_volumes,
++				sizeof(SHADOW_COPY_LABEL),
++				shadow_copy2_label_cmp_asc);
++		} else if (strcmp(tmp_str, "desc") == 0) {
++			qsort(shadow_copy2_data->labels,
++				shadow_copy2_data->num_volumes,
++				sizeof(SHADOW_COPY_LABEL),
++				shadow_copy2_label_cmp_desc);
++		}
++	}
++
++	return;
++}
++
+ static int shadow_copy2_get_shadow_copy2_data(vfs_handle_struct *handle, 
+ 					      files_struct *fsp, 
+ 					      SHADOW_COPY_DATA *shadow_copy2_data, 
+@@ -727,6 +873,7 @@
+ 	const char *snapdir;
+ 	SMB_STRUCT_DIRENT *d;
+ 	TALLOC_CTX *tmp_ctx = talloc_new(handle->data);
++	char *snapshot;
+ 
+ 	snapdir = shadow_copy2_find_snapdir(tmp_ctx, handle);
+ 	if (snapdir == NULL) {
+@@ -747,8 +894,6 @@
+ 		return -1;
+ 	}
+ 
+-	talloc_free(tmp_ctx);
+-
+ 	shadow_copy2_data->num_volumes = 0;
+ 	shadow_copy2_data->labels      = NULL;
+ 
+@@ -756,7 +901,9 @@
+ 		SHADOW_COPY_LABEL *tlabels;
+ 
+ 		/* ignore names not of the right form in the snapshot directory */
+-		if (!shadow_copy2_match_name(d->d_name, NULL)) {
++ 		snapshot = shadow_copy2_snapshot_to_gmt(tmp_ctx, handle, d->d_name);
++ 		DEBUG(6,("shadow_copy2_get_shadow_copy2_data: %s -> %s\n", d->d_name, snapshot));
++ 		if (!snapshot) {
+ 			continue;
+ 		}
+ 
+@@ -772,15 +919,22 @@
+ 		if (tlabels == NULL) {
+ 			DEBUG(0,("shadow_copy2: out of memory\n"));
+ 			SMB_VFS_NEXT_CLOSEDIR(handle, p);
++			talloc_free(tmp_ctx);
+ 			return -1;
+ 		}
+ 
+-		strlcpy(tlabels[shadow_copy2_data->num_volumes], d->d_name, sizeof(*tlabels));
++		strlcpy(tlabels[shadow_copy2_data->num_volumes], snapshot, sizeof(*tlabels));
++		talloc_free(snapshot);
++
+ 		shadow_copy2_data->num_volumes++;
+ 		shadow_copy2_data->labels = tlabels;
+ 	}
+ 
+ 	SMB_VFS_NEXT_CLOSEDIR(handle,p);
++
++	shadow_copy2_sort_data(handle, shadow_copy2_data);
++
++	talloc_free(tmp_ctx);
+ 	return 0;
+ }
+ 
Index: net/samba35/files/sernet.patch
===================================================================
RCS file: /home/ncvs/ports/net/samba35/files/sernet.patch,v
retrieving revision 1.2
diff -u -p -r1.2 sernet.patch
--- net/samba35/files/sernet.patch	20 Jun 2011 02:56:30 -0000	1.2
+++ net/samba35/files/sernet.patch	9 Aug 2011 19:30:02 -0000
@@ -616,83 +616,3 @@ index 675c92e..f5a4444 100644
 -- 
 1.7.0.2
 
---- a/source3/configure	2010-04-06 13:05:13.000000000 +0000
-+++ b/source3/configure	2010-04-14 09:28:51.000000000 +0000
-@@ -13401,6 +13401,7 @@
- default_static_modules="pdb_smbpasswd pdb_tdbsam pdb_wbc_sam rpc_lsarpc rpc_samr rpc_winreg rpc_initshutdown rpc_dssetup rpc_wkssvc rpc_svcctl rpc_ntsvcs rpc_netlogon rpc_netdfs rpc_srvsvc rpc_spoolss rpc_eventlog auth_sam auth_unix auth_winbind auth_wbc auth_server auth_domain auth_builtin auth_netlogond vfs_default nss_info_template"
- 
- default_shared_modules="vfs_recycle vfs_audit vfs_extd_audit vfs_full_audit vfs_netatalk vfs_fake_perms vfs_default_quota vfs_readonly vfs_cap vfs_expand_msdfs vfs_shadow_copy vfs_shadow_copy2 charset_CP850 charset_CP437 auth_script vfs_readahead vfs_xattr_tdb vfs_streams_xattr vfs_streams_depot vfs_acl_xattr vfs_acl_tdb vfs_smb_traffic_analyzer vfs_preopen vfs_catia vfs_scannedonly"
-+default_shared_modules="$default_shared_modules vfs_crossrename"
- 
- if test "x$developer" = xyes; then
-    default_static_modules="$default_static_modules rpc_rpcecho pdb_ads"
-@@ -87389,6 +87371,43 @@
- 		{ $as_echo "$as_me:$LINENO: result: not" >&5
- $as_echo "not" >&6; }
- 	fi
-+
-+
-+	{ $as_echo "$as_me:$LINENO: checking how to build vfs_crossrename" >&5
-+$as_echo_n "checking how to build vfs_crossrename... " >&6; }
-+	if test "$MODULE_vfs_crossrename"; then
-+		DEST=$MODULE_vfs_crossrename
-+	elif test "$MODULE_vfs" -a "$MODULE_DEFAULT_vfs_crossrename"; then
-+		DEST=$MODULE_vfs
-+	else
-+		DEST=$MODULE_DEFAULT_vfs_crossrename
-+	fi
-+
-+	if test x"$DEST" = xSHARED; then
-+
-+cat >>confdefs.h <<\_ACEOF
-+#define vfs_crossrename_init init_samba_module
-+_ACEOF
-+
-+		VFS_MODULES="$VFS_MODULES "bin/crossrename.$SHLIBEXT""
-+		{ $as_echo "$as_me:$LINENO: result: shared" >&5
-+$as_echo "shared" >&6; }
-+
-+		string_shared_modules="$string_shared_modules vfs_crossrename"
-+	elif test x"$DEST" = xSTATIC; then
-+		init_static_modules_vfs="$init_static_modules_vfs  vfs_crossrename_init();"
-+ 		decl_static_modules_vfs="$decl_static_modules_vfs extern NTSTATUS vfs_crossrename_init(void);"
-+		string_static_modules="$string_static_modules vfs_crossrename"
-+		VFS_STATIC="$VFS_STATIC \$(VFS_CROSSRENAME_OBJ)"
-+
-+
-+		{ $as_echo "$as_me:$LINENO: result: static" >&5
-+$as_echo "static" >&6; }
-+	else
-+	    string_ignored_modules="$string_ignored_modules vfs_crossrename"
-+		{ $as_echo "$as_me:$LINENO: result: not" >&5
-+$as_echo "not" >&6; }
-+	fi
- 
- 
- 
-From 0b0c5596034a007b71785a0f36aaf40cf74b234d Mon Sep 17 00:00:00 2001
-From: Volker Lendecke <vl@samba.org>
-Date: Thu, 16 Jun 2011 22:20:49 +0200
-Subject: [PATCH] s3: Fix bug 8238 -- KB2536276 prevents access to shares
-
-Without this we were not sending the workgroup name in the negprot reply if
-plain text passwords are used.
----
- source3/smbd/negprot.c |    1 +
- 1 files changed, 1 insertions(+), 0 deletions(-)
-
-diff --git a/source3/smbd/negprot.c b/source3/smbd/negprot.c
-index 81d29d9..51ad80d 100644
---- a/source3/smbd/negprot.c
-+++ b/source3/smbd/negprot.c
-@@ -382,6 +382,7 @@ static void reply_nt1(struct smb_request *req, uint16 choice)
- 			reply_nterror(req, NT_STATUS_NO_MEMORY);
- 			return;
- 		}
-+		p += ret;
- 		DEBUG(3,("not using SPNEGO\n"));
- 	} else {
- 		DATA_BLOB spnego_blob = negprot_spnego();
--- 
-1.5.6.5
-
Index: net/samba35/files/smb.conf.sample.in
===================================================================
RCS file: /home/ncvs/ports/net/samba35/files/smb.conf.sample.in,v
retrieving revision 1.1
diff -u -p -r1.1 smb.conf.sample.in
--- net/samba35/files/smb.conf.sample.in	26 Oct 2010 02:41:58 -0000	1.1
+++ net/samba35/files/smb.conf.sample.in	9 Aug 2011 19:30:02 -0000
@@ -151,7 +151,7 @@
 
 # DNS Proxy - tells Samba whether or not to try to resolve NetBIOS names
 # via DNS nslookups. The default is NO.
-   dns proxy = no 
+   dns proxy = no
 
 # Charset settings
 ;   display charset = koi8-r
@@ -159,6 +159,7 @@
 ;   dos charset = cp866
 
 # Use extended attributes to store file modes
+;    ea support = yes
 ;    store dos attributes = yes
 ;    map hidden = no
 ;    map system = no
@@ -167,7 +168,7 @@
 # Use inherited ACLs for directories
 ;    nt acl support = yes
 ;    inherit acls = yes
-;    map acl inherit = yes 
+;    map acl inherit = yes
 
 # These scripts are used on a domain controller or stand-alone 
 # machine to add or delete corresponding unix accounts
